Tokens reconocidos:
DEF: def
IDENTIFIER: insertion_sort
LPAREN: (
IDENTIFIER: arr
RPAREN: )
RAISE: raise
STRING: El parÃ¡metro debe ser un arreglo
IDENTIFIER: unless
IDENTIFIER: arr
DOT: .
IDENTIFIER: is_a
LPAREN: (
CONSTANT: Array
RPAREN: )
RAISE: raise
STRING: El arreglo no puede estar vacÃ­o
IF: if
IDENTIFIER: arr
DOT: .
IDENTIFIER: empty
FOR: for
IDENTIFIER: i
IN: in
INTEGER: 1
RANGE: ..
IDENTIFIER: arr
DOT: .
IDENTIFIER: length
MINUS: -
INTEGER: 1
IDENTIFIER: key
ASSIGN: =
IDENTIFIER: arr
LBRACKET: [
IDENTIFIER: i
RBRACKET: ]
IDENTIFIER: j
ASSIGN: =
IDENTIFIER: i
MINUS: -
INTEGER: 1
WHILE: while
IDENTIFIER: j
GREATER_EQUAL: >=
INTEGER: 0
AND: &&
IDENTIFIER: arr
LBRACKET: [
IDENTIFIER: j
RBRACKET: ]
GREATER: >
IDENTIFIER: key
IDENTIFIER: arr
LBRACKET: [
IDENTIFIER: j
PLUS: +
INTEGER: 1
RBRACKET: ]
ASSIGN: =
IDENTIFIER: arr
LBRACKET: [
IDENTIFIER: j
RBRACKET: ]
IDENTIFIER: j
MINUS_ASSIGN: -=
INTEGER: 1
END: end
IDENTIFIER: arr
LBRACKET: [
IDENTIFIER: j
PLUS: +
INTEGER: 1
RBRACKET: ]
ASSIGN: =
IDENTIFIER: key
END: end
RETURN: return
IDENTIFIER: arr
RESCUE: rescue
ASSIGN: =
GREATER: >
IDENTIFIER: e
PUTS: puts
STRING: Error: #{e.message}
RETURN: return
LBRACKET: [
RBRACKET: ]
END: end
DEF: def
IDENTIFIER: print_array
LPAREN: (
IDENTIFIER: arr
RPAREN: )
PUTS: puts
STRING: Arreglo: [#{arr.join(
COMMA: ,
STRING: )}]
END: end
BEGIN: begin
IDENTIFIER: arr1
ASSIGN: =
LBRACKET: [
INTEGER: 12
COMMA: ,
INTEGER: 11
COMMA: ,
INTEGER: 13
COMMA: ,
INTEGER: 5
COMMA: ,
INTEGER: 6
RBRACKET: ]
PUTS: puts
STRING: Arreglo original: #{arr1}
IDENTIFIER: sorted_arr1
ASSIGN: =
IDENTIFIER: insertion_sort
LPAREN: (
IDENTIFIER: arr1
RPAREN: )
PUTS: puts
STRING: Arreglo ordenado: #{sorted_arr1}
IDENTIFIER: arr2
ASSIGN: =
LBRACKET: [
RBRACKET: ]
PUTS: puts
STRING: \nArreglo vacÃ­o:
IDENTIFIER: sorted_arr2
ASSIGN: =
IDENTIFIER: insertion_sort
LPAREN: (
IDENTIFIER: arr2
RPAREN: )
IDENTIFIER: print_array
LPAREN: (
IDENTIFIER: sorted_arr2
RPAREN: )
IDENTIFIER: arr3
ASSIGN: =
LBRACKET: [
INTEGER: 8
RBRACKET: ]
PUTS: puts
STRING: \nArreglo con un solo elemento:
IDENTIFIER: sorted_arr3
ASSIGN: =
IDENTIFIER: insertion_sort
LPAREN: (
IDENTIFIER: arr3
RPAREN: )
IDENTIFIER: print_array
LPAREN: (
IDENTIFIER: sorted_arr3
RPAREN: )
IDENTIFIER: arr4
ASSIGN: =
LBRACKET: [
MINUS: -
INTEGER: 5
COMMA: ,
MINUS: -
INTEGER: 9
COMMA: ,
MINUS: -
INTEGER: 1
COMMA: ,
MINUS: -
INTEGER: 4
COMMA: ,
MINUS: -
INTEGER: 7
RBRACKET: ]
PUTS: puts
STRING: \nArreglo con nÃºmeros negativos:
IDENTIFIER: sorted_arr4
ASSIGN: =
IDENTIFIER: insertion_sort
LPAREN: (
IDENTIFIER: arr4
RPAREN: )
IDENTIFIER: print_array
LPAREN: (
IDENTIFIER: sorted_arr4
RPAREN: )
IDENTIFIER: arr5
ASSIGN: =
LBRACKET: [
INTEGER: 15
COMMA: ,
MINUS: -
INTEGER: 2
COMMA: ,
INTEGER: 9
COMMA: ,
MINUS: -
INTEGER: 8
COMMA: ,
INTEGER: 6
COMMA: ,
INTEGER: 7
RBRACKET: ]
PUTS: puts
STRING: \nArreglo mixto (positivos y negativos):
IDENTIFIER: sorted_arr5
ASSIGN: =
IDENTIFIER: insertion_sort
LPAREN: (
IDENTIFIER: arr5
RPAREN: )
IDENTIFIER: print_array
LPAREN: (
IDENTIFIER: sorted_arr5
RPAREN: )
RESCUE: rescue
ASSIGN: =
GREATER: >
IDENTIFIER: e
PUTS: puts
STRING: ExcepciÃ³n capturada: #{e.message}
ENSURE: ensure
PUTS: puts
STRING: \nFin de la ejecuciÃ³n de Insertion Sort.
END: end

Errores léxicos:
Error léxico: ? en la línea 11
Error léxico: ? en la línea 12
