Tokens reconocidos:
CONSTANT: Algoritmo
IDENTIFIER: de
CONSTANT: Ordenamiento
IDENTIFIER: por
CONSTANT: Inserci
IDENTIFIER: n
CONSTANT: Mejorado
DEF: def
IDENTIFIER: insertion_sort
LPAREN: (
IDENTIFIER: arr
RPAREN: )
CONSTANT: Verificar
IDENTIFIER: si
IDENTIFIER: el
IDENTIFIER: par
IDENTIFIER: metro
IDENTIFIER: es
IDENTIFIER: un
IDENTIFIER: arreglo
RAISE: raise
STRING: El parámetro debe ser un arreglo
IDENTIFIER: unless
IDENTIFIER: arr
DOT: .
IDENTIFIER: is_a?
LPAREN: (
CONSTANT: Array
RPAREN: )
RAISE: raise
STRING: El arreglo no puede estar vacío
IF: if
IDENTIFIER: arr
DOT: .
IDENTIFIER: empty?
FOR: for
IDENTIFIER: i
IN: in
INTEGER: 1
RANGE: ..
IDENTIFIER: arr
DOT: .
IDENTIFIER: length
MINUS: -
INTEGER: 1
IDENTIFIER: key
ASSIGN: =
IDENTIFIER: arr
LBRACKET: [
IDENTIFIER: i
RBRACKET: ]
IDENTIFIER: j
ASSIGN: =
IDENTIFIER: i
MINUS: -
INTEGER: 1
CONSTANT: Mover
IDENTIFIER: los
IDENTIFIER: elementos
IDENTIFIER: de
IDENTIFIER: arr
LBRACKET: [
INTEGER: 0
RANGE: ..
IDENTIFIER: i
MINUS: -
INTEGER: 1
RBRACKET: ]
IDENTIFIER: que
IDENTIFIER: son
IDENTIFIER: mayores
IDENTIFIER: que
IDENTIFIER: key
COMMA: ,
IDENTIFIER: una
IDENTIFIER: posici
IDENTIFIER: n
IDENTIFIER: hacia
IDENTIFIER: adelante
WHILE: while
IDENTIFIER: j
GREATER_EQUAL: >=
INTEGER: 0
AND: &&
IDENTIFIER: arr
LBRACKET: [
IDENTIFIER: j
RBRACKET: ]
GREATER: >
IDENTIFIER: key
IDENTIFIER: arr
LBRACKET: [
IDENTIFIER: j
PLUS: +
INTEGER: 1
RBRACKET: ]
ASSIGN: =
IDENTIFIER: arr
LBRACKET: [
IDENTIFIER: j
RBRACKET: ]
IDENTIFIER: j
MINUS_ASSIGN: -=
INTEGER: 1
END: end
IDENTIFIER: arr
LBRACKET: [
IDENTIFIER: j
PLUS: +
INTEGER: 1
RBRACKET: ]
ASSIGN: =
IDENTIFIER: key
END: end
RETURN: return
IDENTIFIER: arr
RESCUE: rescue
HASH_ROCKET: =>
IDENTIFIER: e
PUTS: puts
STRING: Error: #{e.message}
RETURN: return
LBRACKET: [
RBRACKET: ]
END: end
CONSTANT: Funci
IDENTIFIER: n
IDENTIFIER: para
IDENTIFIER: imprimir
IDENTIFIER: el
IDENTIFIER: arreglo
IDENTIFIER: de
IDENTIFIER: manera
IDENTIFIER: m
IDENTIFIER: s
IDENTIFIER: visual
DEF: def
IDENTIFIER: print_array
LPAREN: (
IDENTIFIER: arr
RPAREN: )
PUTS: puts
STRING: Arreglo: [#{arr.join(
COMMA: ,
STRING: )}]
END: end
CONSTANT: Prueba
IDENTIFIER: de
CONSTANT: Insertion
CONSTANT: Sort
IDENTIFIER: con
IDENTIFIER: m
IDENTIFIER: ltiples
IDENTIFIER: escenarios
BEGIN: begin
IDENTIFIER: arr1
ASSIGN: =
LBRACKET: [
INTEGER: 12
COMMA: ,
INTEGER: 11
COMMA: ,
INTEGER: 13
COMMA: ,
INTEGER: 5
COMMA: ,
INTEGER: 6
RBRACKET: ]
PUTS: puts
STRING: Arreglo original: #{arr1}
IDENTIFIER: sorted_arr1
ASSIGN: =
IDENTIFIER: insertion_sort
LPAREN: (
IDENTIFIER: arr1
RPAREN: )
PUTS: puts
STRING: Arreglo ordenado: #{sorted_arr1}
CONSTANT: Caso
IDENTIFIER: con
IDENTIFIER: arreglo
IDENTIFIER: vac
IDENTIFIER: o
IDENTIFIER: arr2
ASSIGN: =
LBRACKET: [
RBRACKET: ]
PUTS: puts
STRING: \nArreglo vacío:
IDENTIFIER: sorted_arr2
ASSIGN: =
IDENTIFIER: insertion_sort
LPAREN: (
IDENTIFIER: arr2
RPAREN: )
IDENTIFIER: print_array
LPAREN: (
IDENTIFIER: sorted_arr2
RPAREN: )
CONSTANT: Caso
IDENTIFIER: con
IDENTIFIER: un
IDENTIFIER: solo
IDENTIFIER: elemento
IDENTIFIER: arr3
ASSIGN: =
LBRACKET: [
INTEGER: 8
RBRACKET: ]
PUTS: puts
STRING: \nArreglo con un solo elemento:
IDENTIFIER: sorted_arr3
ASSIGN: =
IDENTIFIER: insertion_sort
LPAREN: (
IDENTIFIER: arr3
RPAREN: )
IDENTIFIER: print_array
LPAREN: (
IDENTIFIER: sorted_arr3
RPAREN: )
CONSTANT: Caso
IDENTIFIER: con
IDENTIFIER: arreglo
IDENTIFIER: de
IDENTIFIER: n
IDENTIFIER: meros
IDENTIFIER: negativos
IDENTIFIER: arr4
ASSIGN: =
LBRACKET: [
MINUS: -
INTEGER: 5
COMMA: ,
MINUS: -
INTEGER: 9
COMMA: ,
MINUS: -
INTEGER: 1
COMMA: ,
MINUS: -
INTEGER: 4
COMMA: ,
MINUS: -
INTEGER: 7
RBRACKET: ]
PUTS: puts
STRING: \nArreglo con números negativos:
IDENTIFIER: sorted_arr4
ASSIGN: =
IDENTIFIER: insertion_sort
LPAREN: (
IDENTIFIER: arr4
RPAREN: )
IDENTIFIER: print_array
LPAREN: (
IDENTIFIER: sorted_arr4
RPAREN: )
CONSTANT: Caso
IDENTIFIER: con
IDENTIFIER: una
IDENTIFIER: mezcla
IDENTIFIER: de
IDENTIFIER: n
IDENTIFIER: meros
IDENTIFIER: positivos
IDENTIFIER: y
IDENTIFIER: negativos
IDENTIFIER: arr5
ASSIGN: =
LBRACKET: [
INTEGER: 15
COMMA: ,
MINUS: -
INTEGER: 2
COMMA: ,
INTEGER: 9
COMMA: ,
MINUS: -
INTEGER: 8
COMMA: ,
INTEGER: 6
COMMA: ,
INTEGER: 7
RBRACKET: ]
PUTS: puts
STRING: \nArreglo mixto (positivos y negativos):
IDENTIFIER: sorted_arr5
ASSIGN: =
IDENTIFIER: insertion_sort
LPAREN: (
IDENTIFIER: arr5
RPAREN: )
IDENTIFIER: print_array
LPAREN: (
IDENTIFIER: sorted_arr5
RPAREN: )
RESCUE: rescue
HASH_ROCKET: =>
IDENTIFIER: e
PUTS: puts
STRING: Excepción capturada: #{e.message}
ENSURE: ensure
PUTS: puts
STRING: \nFin de la ejecución de Insertion Sort.
END: end

Errores léxicos:
Error léxico: # en la línea 1
Error léxico: ó en la línea 1
Error léxico: # en la línea 3
Error léxico: á en la línea 3
Error léxico: # en la línea 11
Error léxico: ó en la línea 11
Error léxico: # en la línea 24
Error léxico: ó en la línea 24
Error léxico: á en la línea 24
Error léxico: # en la línea 29
Error léxico: ú en la línea 29
Error léxico: # en la línea 36
Error léxico: í en la línea 36
Error léxico: # en la línea 42
Error léxico: # en la línea 48
Error léxico: ú en la línea 48
Error léxico: # en la línea 54
Error léxico: ú en la línea 54
