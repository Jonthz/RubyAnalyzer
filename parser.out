Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    BEGIN
    BITWISE_AND
    BREAK
    CASE
    CLASS
    CLASS_VAR
    COMMENT
    CONSTANT
    DIVIDE_ASSIGN
    DO
    DOT
    ELSE
    ELSIF
    ENSURE
    EQUALS
    FALSE
    FLOOR_DIVIDE
    GLOBAL_VAR
    GREATER
    GREATER_EQUAL
    IF
    LAMBDA
    LBRACE
    LESS
    LESS_EQUAL
    MINUS_ASSIGN
    MOD
    MODULE
    MOD_ASSIGN
    NEXT
    NIL
    NOT
    NOT_EQUALS
    OR
    PIPE
    PLUS_ASSIGN
    POWER
    POWER_ASSIGN
    PROC
    QUESTION_MARK
    RAISE
    RANGE
    RBRACE
    REDO
    REQUIRE
    RESCUE
    RETRY
    RETURN
    SELF
    SEMICOLON
    SPACESHIP
    STRING
    SUPER
    TIMES_ASSIGN
    TRUE
    UNTIL
    WHEN
    YIELD

Grammar

Rule 0     S' -> program
Rule 1     program -> statements END
Rule 2     program -> statements
Rule 3     params -> IDENTIFIER
Rule 4     params -> params COMMA IDENTIFIER
Rule 5     statements -> statement
Rule 6     statements -> statements statement
Rule 7     statement -> expression
Rule 8     statement -> IDENTIFIER ASSIGN INTEGER
Rule 9     statement -> IDENTIFIER ASSIGN FLOAT
Rule 10    statement -> INSTANCE_VAR ASSIGN INTEGER
Rule 11    statement -> INSTANCE_VAR ASSIGN FLOAT
Rule 12    expression -> SETNEW LPAREN elements RPAREN
Rule 13    statement -> WHILE expression statement END
Rule 14    statement -> IDENTIFIER ASSIGN GETS
Rule 15    expression -> term
Rule 16    term -> factor DIVIDE factor
Rule 17    term -> factor TIMES factor
Rule 18    expression -> expression PLUS factor
Rule 19    expression -> expression MINUS factor
Rule 20    factor -> INTEGER
Rule 21    factor -> FLOAT
Rule 22    factor -> LPAREN expression RPAREN
Rule 23    expression -> LBRACKET elements RBRACKET
Rule 24    elements -> expression
Rule 25    elements -> elements COMMA expression
Rule 26    statement -> DEF IDENTIFIER LPAREN params RPAREN statement END
Rule 27    statement -> IDENTIFIER LPAREN params RPAREN
Rule 28    statement -> FOR IDENTIFIER IN range statement
Rule 29    range -> INTEGER DOUBLE_DOT INTEGER
Rule 30    range -> FLOAT DOUBLE_DOT FLOAT
Rule 31    statement -> PUTS statement

Terminals, with rules where they appear

AND                  : 
ASSIGN               : 8 9 10 11 14
BEGIN                : 
BITWISE_AND          : 
BREAK                : 
CASE                 : 
CLASS                : 
CLASS_VAR            : 
COMMA                : 4 25
COMMENT              : 
CONSTANT             : 
DEF                  : 26
DIVIDE               : 16
DIVIDE_ASSIGN        : 
DO                   : 
DOT                  : 
DOUBLE_DOT           : 29 30
ELSE                 : 
ELSIF                : 
END                  : 1 13 26
ENSURE               : 
EQUALS               : 
FALSE                : 
FLOAT                : 9 11 21 30 30
FLOOR_DIVIDE         : 
FOR                  : 28
GETS                 : 14
GLOBAL_VAR           : 
GREATER              : 
GREATER_EQUAL        : 
IDENTIFIER           : 3 4 8 9 14 26 27 28
IF                   : 
IN                   : 28
INSTANCE_VAR         : 10 11
INTEGER              : 8 10 20 29 29
LAMBDA               : 
LBRACE               : 
LBRACKET             : 23
LESS                 : 
LESS_EQUAL           : 
LPAREN               : 12 22 26 27
MINUS                : 19
MINUS_ASSIGN         : 
MOD                  : 
MODULE               : 
MOD_ASSIGN           : 
NEXT                 : 
NIL                  : 
NOT                  : 
NOT_EQUALS           : 
OR                   : 
PIPE                 : 
PLUS                 : 18
PLUS_ASSIGN          : 
POWER                : 
POWER_ASSIGN         : 
PROC                 : 
PUTS                 : 31
QUESTION_MARK        : 
RAISE                : 
RANGE                : 
RBRACE               : 
RBRACKET             : 23
REDO                 : 
REQUIRE              : 
RESCUE               : 
RETRY                : 
RETURN               : 
RPAREN               : 12 22 26 27
SELF                 : 
SEMICOLON            : 
SETNEW               : 12
SPACESHIP            : 
STRING               : 
SUPER                : 
TIMES                : 17
TIMES_ASSIGN         : 
TRUE                 : 
UNTIL                : 
WHEN                 : 
WHILE                : 13
YIELD                : 
error                : 

Nonterminals, with rules where they appear

elements             : 12 23 25
expression           : 7 13 18 19 22 24 25
factor               : 16 16 17 17 18 19
params               : 4 26 27
program              : 0
range                : 28
statement            : 5 6 13 26 28 31
statements           : 1 2 6
term                 : 15

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statements END
    (2) program -> . statements
    (5) statements -> . statement
    (6) statements -> . statements statement
    (7) statement -> . expression
    (8) statement -> . IDENTIFIER ASSIGN INTEGER
    (9) statement -> . IDENTIFIER ASSIGN FLOAT
    (10) statement -> . INSTANCE_VAR ASSIGN INTEGER
    (11) statement -> . INSTANCE_VAR ASSIGN FLOAT
    (13) statement -> . WHILE expression statement END
    (14) statement -> . IDENTIFIER ASSIGN GETS
    (26) statement -> . DEF IDENTIFIER LPAREN params RPAREN statement END
    (27) statement -> . IDENTIFIER LPAREN params RPAREN
    (28) statement -> . FOR IDENTIFIER IN range statement
    (31) statement -> . PUTS statement
    (12) expression -> . SETNEW LPAREN elements RPAREN
    (15) expression -> . term
    (18) expression -> . expression PLUS factor
    (19) expression -> . expression MINUS factor
    (23) expression -> . LBRACKET elements RBRACKET
    (16) term -> . factor DIVIDE factor
    (17) term -> . factor TIMES factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 5
    INSTANCE_VAR    shift and go to state 8
    WHILE           shift and go to state 9
    DEF             shift and go to state 10
    FOR             shift and go to state 12
    PUTS            shift and go to state 13
    SETNEW          shift and go to state 14
    LBRACKET        shift and go to state 17
    INTEGER         shift and go to state 6
    FLOAT           shift and go to state 7
    LPAREN          shift and go to state 11

    program                        shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    term                           shift and go to state 15
    factor                         shift and go to state 16

state 1

    (0) S' -> program .



state 2

    (1) program -> statements . END
    (2) program -> statements .
    (6) statements -> statements . statement
    (7) statement -> . expression
    (8) statement -> . IDENTIFIER ASSIGN INTEGER
    (9) statement -> . IDENTIFIER ASSIGN FLOAT
    (10) statement -> . INSTANCE_VAR ASSIGN INTEGER
    (11) statement -> . INSTANCE_VAR ASSIGN FLOAT
    (13) statement -> . WHILE expression statement END
    (14) statement -> . IDENTIFIER ASSIGN GETS
    (26) statement -> . DEF IDENTIFIER LPAREN params RPAREN statement END
    (27) statement -> . IDENTIFIER LPAREN params RPAREN
    (28) statement -> . FOR IDENTIFIER IN range statement
    (31) statement -> . PUTS statement
    (12) expression -> . SETNEW LPAREN elements RPAREN
    (15) expression -> . term
    (18) expression -> . expression PLUS factor
    (19) expression -> . expression MINUS factor
    (23) expression -> . LBRACKET elements RBRACKET
    (16) term -> . factor DIVIDE factor
    (17) term -> . factor TIMES factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . LPAREN expression RPAREN

    END             shift and go to state 18
    $end            reduce using rule 2 (program -> statements .)
    IDENTIFIER      shift and go to state 5
    INSTANCE_VAR    shift and go to state 8
    WHILE           shift and go to state 9
    DEF             shift and go to state 10
    FOR             shift and go to state 12
    PUTS            shift and go to state 13
    SETNEW          shift and go to state 14
    LBRACKET        shift and go to state 17
    INTEGER         shift and go to state 6
    FLOAT           shift and go to state 7
    LPAREN          shift and go to state 11

    statement                      shift and go to state 19
    expression                     shift and go to state 4
    term                           shift and go to state 15
    factor                         shift and go to state 16

state 3

    (5) statements -> statement .

    END             reduce using rule 5 (statements -> statement .)
    IDENTIFIER      reduce using rule 5 (statements -> statement .)
    INSTANCE_VAR    reduce using rule 5 (statements -> statement .)
    WHILE           reduce using rule 5 (statements -> statement .)
    DEF             reduce using rule 5 (statements -> statement .)
    FOR             reduce using rule 5 (statements -> statement .)
    PUTS            reduce using rule 5 (statements -> statement .)
    SETNEW          reduce using rule 5 (statements -> statement .)
    LBRACKET        reduce using rule 5 (statements -> statement .)
    INTEGER         reduce using rule 5 (statements -> statement .)
    FLOAT           reduce using rule 5 (statements -> statement .)
    LPAREN          reduce using rule 5 (statements -> statement .)
    $end            reduce using rule 5 (statements -> statement .)


state 4

    (7) statement -> expression .
    (18) expression -> expression . PLUS factor
    (19) expression -> expression . MINUS factor

    END             reduce using rule 7 (statement -> expression .)
    IDENTIFIER      reduce using rule 7 (statement -> expression .)
    INSTANCE_VAR    reduce using rule 7 (statement -> expression .)
    WHILE           reduce using rule 7 (statement -> expression .)
    DEF             reduce using rule 7 (statement -> expression .)
    FOR             reduce using rule 7 (statement -> expression .)
    PUTS            reduce using rule 7 (statement -> expression .)
    SETNEW          reduce using rule 7 (statement -> expression .)
    LBRACKET        reduce using rule 7 (statement -> expression .)
    INTEGER         reduce using rule 7 (statement -> expression .)
    FLOAT           reduce using rule 7 (statement -> expression .)
    LPAREN          reduce using rule 7 (statement -> expression .)
    $end            reduce using rule 7 (statement -> expression .)
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21


state 5

    (8) statement -> IDENTIFIER . ASSIGN INTEGER
    (9) statement -> IDENTIFIER . ASSIGN FLOAT
    (14) statement -> IDENTIFIER . ASSIGN GETS
    (27) statement -> IDENTIFIER . LPAREN params RPAREN

    ASSIGN          shift and go to state 22
    LPAREN          shift and go to state 23


state 6

    (20) factor -> INTEGER .

    DIVIDE          reduce using rule 20 (factor -> INTEGER .)
    TIMES           reduce using rule 20 (factor -> INTEGER .)
    PLUS            reduce using rule 20 (factor -> INTEGER .)
    MINUS           reduce using rule 20 (factor -> INTEGER .)
    END             reduce using rule 20 (factor -> INTEGER .)
    IDENTIFIER      reduce using rule 20 (factor -> INTEGER .)
    INSTANCE_VAR    reduce using rule 20 (factor -> INTEGER .)
    WHILE           reduce using rule 20 (factor -> INTEGER .)
    DEF             reduce using rule 20 (factor -> INTEGER .)
    FOR             reduce using rule 20 (factor -> INTEGER .)
    PUTS            reduce using rule 20 (factor -> INTEGER .)
    SETNEW          reduce using rule 20 (factor -> INTEGER .)
    LBRACKET        reduce using rule 20 (factor -> INTEGER .)
    INTEGER         reduce using rule 20 (factor -> INTEGER .)
    FLOAT           reduce using rule 20 (factor -> INTEGER .)
    LPAREN          reduce using rule 20 (factor -> INTEGER .)
    $end            reduce using rule 20 (factor -> INTEGER .)
    RPAREN          reduce using rule 20 (factor -> INTEGER .)
    RBRACKET        reduce using rule 20 (factor -> INTEGER .)
    COMMA           reduce using rule 20 (factor -> INTEGER .)


state 7

    (21) factor -> FLOAT .

    DIVIDE          reduce using rule 21 (factor -> FLOAT .)
    TIMES           reduce using rule 21 (factor -> FLOAT .)
    PLUS            reduce using rule 21 (factor -> FLOAT .)
    MINUS           reduce using rule 21 (factor -> FLOAT .)
    END             reduce using rule 21 (factor -> FLOAT .)
    IDENTIFIER      reduce using rule 21 (factor -> FLOAT .)
    INSTANCE_VAR    reduce using rule 21 (factor -> FLOAT .)
    WHILE           reduce using rule 21 (factor -> FLOAT .)
    DEF             reduce using rule 21 (factor -> FLOAT .)
    FOR             reduce using rule 21 (factor -> FLOAT .)
    PUTS            reduce using rule 21 (factor -> FLOAT .)
    SETNEW          reduce using rule 21 (factor -> FLOAT .)
    LBRACKET        reduce using rule 21 (factor -> FLOAT .)
    INTEGER         reduce using rule 21 (factor -> FLOAT .)
    FLOAT           reduce using rule 21 (factor -> FLOAT .)
    LPAREN          reduce using rule 21 (factor -> FLOAT .)
    $end            reduce using rule 21 (factor -> FLOAT .)
    RPAREN          reduce using rule 21 (factor -> FLOAT .)
    RBRACKET        reduce using rule 21 (factor -> FLOAT .)
    COMMA           reduce using rule 21 (factor -> FLOAT .)


state 8

    (10) statement -> INSTANCE_VAR . ASSIGN INTEGER
    (11) statement -> INSTANCE_VAR . ASSIGN FLOAT

    ASSIGN          shift and go to state 24


state 9

    (13) statement -> WHILE . expression statement END
    (12) expression -> . SETNEW LPAREN elements RPAREN
    (15) expression -> . term
    (18) expression -> . expression PLUS factor
    (19) expression -> . expression MINUS factor
    (23) expression -> . LBRACKET elements RBRACKET
    (16) term -> . factor DIVIDE factor
    (17) term -> . factor TIMES factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . LPAREN expression RPAREN

    SETNEW          shift and go to state 14
    LBRACKET        shift and go to state 17
    INTEGER         shift and go to state 6
    FLOAT           shift and go to state 7
    LPAREN          shift and go to state 11

    expression                     shift and go to state 25
    term                           shift and go to state 15
    factor                         shift and go to state 16

state 10

    (26) statement -> DEF . IDENTIFIER LPAREN params RPAREN statement END

    IDENTIFIER      shift and go to state 26


state 11

    (22) factor -> LPAREN . expression RPAREN
    (12) expression -> . SETNEW LPAREN elements RPAREN
    (15) expression -> . term
    (18) expression -> . expression PLUS factor
    (19) expression -> . expression MINUS factor
    (23) expression -> . LBRACKET elements RBRACKET
    (16) term -> . factor DIVIDE factor
    (17) term -> . factor TIMES factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . LPAREN expression RPAREN

    SETNEW          shift and go to state 14
    LBRACKET        shift and go to state 17
    INTEGER         shift and go to state 6
    FLOAT           shift and go to state 7
    LPAREN          shift and go to state 11

    expression                     shift and go to state 27
    term                           shift and go to state 15
    factor                         shift and go to state 16

state 12

    (28) statement -> FOR . IDENTIFIER IN range statement

    IDENTIFIER      shift and go to state 28


state 13

    (31) statement -> PUTS . statement
    (7) statement -> . expression
    (8) statement -> . IDENTIFIER ASSIGN INTEGER
    (9) statement -> . IDENTIFIER ASSIGN FLOAT
    (10) statement -> . INSTANCE_VAR ASSIGN INTEGER
    (11) statement -> . INSTANCE_VAR ASSIGN FLOAT
    (13) statement -> . WHILE expression statement END
    (14) statement -> . IDENTIFIER ASSIGN GETS
    (26) statement -> . DEF IDENTIFIER LPAREN params RPAREN statement END
    (27) statement -> . IDENTIFIER LPAREN params RPAREN
    (28) statement -> . FOR IDENTIFIER IN range statement
    (31) statement -> . PUTS statement
    (12) expression -> . SETNEW LPAREN elements RPAREN
    (15) expression -> . term
    (18) expression -> . expression PLUS factor
    (19) expression -> . expression MINUS factor
    (23) expression -> . LBRACKET elements RBRACKET
    (16) term -> . factor DIVIDE factor
    (17) term -> . factor TIMES factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 5
    INSTANCE_VAR    shift and go to state 8
    WHILE           shift and go to state 9
    DEF             shift and go to state 10
    FOR             shift and go to state 12
    PUTS            shift and go to state 13
    SETNEW          shift and go to state 14
    LBRACKET        shift and go to state 17
    INTEGER         shift and go to state 6
    FLOAT           shift and go to state 7
    LPAREN          shift and go to state 11

    statement                      shift and go to state 29
    expression                     shift and go to state 4
    term                           shift and go to state 15
    factor                         shift and go to state 16

state 14

    (12) expression -> SETNEW . LPAREN elements RPAREN

    LPAREN          shift and go to state 30


state 15

    (15) expression -> term .

    PLUS            reduce using rule 15 (expression -> term .)
    MINUS           reduce using rule 15 (expression -> term .)
    END             reduce using rule 15 (expression -> term .)
    IDENTIFIER      reduce using rule 15 (expression -> term .)
    INSTANCE_VAR    reduce using rule 15 (expression -> term .)
    WHILE           reduce using rule 15 (expression -> term .)
    DEF             reduce using rule 15 (expression -> term .)
    FOR             reduce using rule 15 (expression -> term .)
    PUTS            reduce using rule 15 (expression -> term .)
    SETNEW          reduce using rule 15 (expression -> term .)
    LBRACKET        reduce using rule 15 (expression -> term .)
    INTEGER         reduce using rule 15 (expression -> term .)
    FLOAT           reduce using rule 15 (expression -> term .)
    LPAREN          reduce using rule 15 (expression -> term .)
    $end            reduce using rule 15 (expression -> term .)
    RPAREN          reduce using rule 15 (expression -> term .)
    RBRACKET        reduce using rule 15 (expression -> term .)
    COMMA           reduce using rule 15 (expression -> term .)


state 16

    (16) term -> factor . DIVIDE factor
    (17) term -> factor . TIMES factor

    DIVIDE          shift and go to state 31
    TIMES           shift and go to state 32


state 17

    (23) expression -> LBRACKET . elements RBRACKET
    (24) elements -> . expression
    (25) elements -> . elements COMMA expression
    (12) expression -> . SETNEW LPAREN elements RPAREN
    (15) expression -> . term
    (18) expression -> . expression PLUS factor
    (19) expression -> . expression MINUS factor
    (23) expression -> . LBRACKET elements RBRACKET
    (16) term -> . factor DIVIDE factor
    (17) term -> . factor TIMES factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . LPAREN expression RPAREN

    SETNEW          shift and go to state 14
    LBRACKET        shift and go to state 17
    INTEGER         shift and go to state 6
    FLOAT           shift and go to state 7
    LPAREN          shift and go to state 11

    elements                       shift and go to state 33
    expression                     shift and go to state 34
    term                           shift and go to state 15
    factor                         shift and go to state 16

state 18

    (1) program -> statements END .

    $end            reduce using rule 1 (program -> statements END .)


state 19

    (6) statements -> statements statement .

    END             reduce using rule 6 (statements -> statements statement .)
    IDENTIFIER      reduce using rule 6 (statements -> statements statement .)
    INSTANCE_VAR    reduce using rule 6 (statements -> statements statement .)
    WHILE           reduce using rule 6 (statements -> statements statement .)
    DEF             reduce using rule 6 (statements -> statements statement .)
    FOR             reduce using rule 6 (statements -> statements statement .)
    PUTS            reduce using rule 6 (statements -> statements statement .)
    SETNEW          reduce using rule 6 (statements -> statements statement .)
    LBRACKET        reduce using rule 6 (statements -> statements statement .)
    INTEGER         reduce using rule 6 (statements -> statements statement .)
    FLOAT           reduce using rule 6 (statements -> statements statement .)
    LPAREN          reduce using rule 6 (statements -> statements statement .)
    $end            reduce using rule 6 (statements -> statements statement .)


state 20

    (18) expression -> expression PLUS . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 6
    FLOAT           shift and go to state 7
    LPAREN          shift and go to state 11

    factor                         shift and go to state 35

state 21

    (19) expression -> expression MINUS . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 6
    FLOAT           shift and go to state 7
    LPAREN          shift and go to state 11

    factor                         shift and go to state 36

state 22

    (8) statement -> IDENTIFIER ASSIGN . INTEGER
    (9) statement -> IDENTIFIER ASSIGN . FLOAT
    (14) statement -> IDENTIFIER ASSIGN . GETS

    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    GETS            shift and go to state 39


state 23

    (27) statement -> IDENTIFIER LPAREN . params RPAREN
    (3) params -> . IDENTIFIER
    (4) params -> . params COMMA IDENTIFIER

    IDENTIFIER      shift and go to state 40

    params                         shift and go to state 41

state 24

    (10) statement -> INSTANCE_VAR ASSIGN . INTEGER
    (11) statement -> INSTANCE_VAR ASSIGN . FLOAT

    INTEGER         shift and go to state 42
    FLOAT           shift and go to state 43


state 25

    (13) statement -> WHILE expression . statement END
    (18) expression -> expression . PLUS factor
    (19) expression -> expression . MINUS factor
    (7) statement -> . expression
    (8) statement -> . IDENTIFIER ASSIGN INTEGER
    (9) statement -> . IDENTIFIER ASSIGN FLOAT
    (10) statement -> . INSTANCE_VAR ASSIGN INTEGER
    (11) statement -> . INSTANCE_VAR ASSIGN FLOAT
    (13) statement -> . WHILE expression statement END
    (14) statement -> . IDENTIFIER ASSIGN GETS
    (26) statement -> . DEF IDENTIFIER LPAREN params RPAREN statement END
    (27) statement -> . IDENTIFIER LPAREN params RPAREN
    (28) statement -> . FOR IDENTIFIER IN range statement
    (31) statement -> . PUTS statement
    (12) expression -> . SETNEW LPAREN elements RPAREN
    (15) expression -> . term
    (18) expression -> . expression PLUS factor
    (19) expression -> . expression MINUS factor
    (23) expression -> . LBRACKET elements RBRACKET
    (16) term -> . factor DIVIDE factor
    (17) term -> . factor TIMES factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . LPAREN expression RPAREN

    PLUS            shift and go to state 20
    MINUS           shift and go to state 21
    IDENTIFIER      shift and go to state 5
    INSTANCE_VAR    shift and go to state 8
    WHILE           shift and go to state 9
    DEF             shift and go to state 10
    FOR             shift and go to state 12
    PUTS            shift and go to state 13
    SETNEW          shift and go to state 14
    LBRACKET        shift and go to state 17
    INTEGER         shift and go to state 6
    FLOAT           shift and go to state 7
    LPAREN          shift and go to state 11

    expression                     shift and go to state 4
    statement                      shift and go to state 44
    factor                         shift and go to state 16
    term                           shift and go to state 15

state 26

    (26) statement -> DEF IDENTIFIER . LPAREN params RPAREN statement END

    LPAREN          shift and go to state 45


state 27

    (22) factor -> LPAREN expression . RPAREN
    (18) expression -> expression . PLUS factor
    (19) expression -> expression . MINUS factor

    RPAREN          shift and go to state 46
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21


state 28

    (28) statement -> FOR IDENTIFIER . IN range statement

    IN              shift and go to state 47


state 29

    (31) statement -> PUTS statement .

    END             reduce using rule 31 (statement -> PUTS statement .)
    IDENTIFIER      reduce using rule 31 (statement -> PUTS statement .)
    INSTANCE_VAR    reduce using rule 31 (statement -> PUTS statement .)
    WHILE           reduce using rule 31 (statement -> PUTS statement .)
    DEF             reduce using rule 31 (statement -> PUTS statement .)
    FOR             reduce using rule 31 (statement -> PUTS statement .)
    PUTS            reduce using rule 31 (statement -> PUTS statement .)
    SETNEW          reduce using rule 31 (statement -> PUTS statement .)
    LBRACKET        reduce using rule 31 (statement -> PUTS statement .)
    INTEGER         reduce using rule 31 (statement -> PUTS statement .)
    FLOAT           reduce using rule 31 (statement -> PUTS statement .)
    LPAREN          reduce using rule 31 (statement -> PUTS statement .)
    $end            reduce using rule 31 (statement -> PUTS statement .)


state 30

    (12) expression -> SETNEW LPAREN . elements RPAREN
    (24) elements -> . expression
    (25) elements -> . elements COMMA expression
    (12) expression -> . SETNEW LPAREN elements RPAREN
    (15) expression -> . term
    (18) expression -> . expression PLUS factor
    (19) expression -> . expression MINUS factor
    (23) expression -> . LBRACKET elements RBRACKET
    (16) term -> . factor DIVIDE factor
    (17) term -> . factor TIMES factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . LPAREN expression RPAREN

    SETNEW          shift and go to state 14
    LBRACKET        shift and go to state 17
    INTEGER         shift and go to state 6
    FLOAT           shift and go to state 7
    LPAREN          shift and go to state 11

    elements                       shift and go to state 48
    expression                     shift and go to state 34
    term                           shift and go to state 15
    factor                         shift and go to state 16

state 31

    (16) term -> factor DIVIDE . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 6
    FLOAT           shift and go to state 7
    LPAREN          shift and go to state 11

    factor                         shift and go to state 49

state 32

    (17) term -> factor TIMES . factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 6
    FLOAT           shift and go to state 7
    LPAREN          shift and go to state 11

    factor                         shift and go to state 50

state 33

    (23) expression -> LBRACKET elements . RBRACKET
    (25) elements -> elements . COMMA expression

    RBRACKET        shift and go to state 51
    COMMA           shift and go to state 52


state 34

    (24) elements -> expression .
    (18) expression -> expression . PLUS factor
    (19) expression -> expression . MINUS factor

    RBRACKET        reduce using rule 24 (elements -> expression .)
    COMMA           reduce using rule 24 (elements -> expression .)
    RPAREN          reduce using rule 24 (elements -> expression .)
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21


state 35

    (18) expression -> expression PLUS factor .

    PLUS            reduce using rule 18 (expression -> expression PLUS factor .)
    MINUS           reduce using rule 18 (expression -> expression PLUS factor .)
    END             reduce using rule 18 (expression -> expression PLUS factor .)
    IDENTIFIER      reduce using rule 18 (expression -> expression PLUS factor .)
    INSTANCE_VAR    reduce using rule 18 (expression -> expression PLUS factor .)
    WHILE           reduce using rule 18 (expression -> expression PLUS factor .)
    DEF             reduce using rule 18 (expression -> expression PLUS factor .)
    FOR             reduce using rule 18 (expression -> expression PLUS factor .)
    PUTS            reduce using rule 18 (expression -> expression PLUS factor .)
    SETNEW          reduce using rule 18 (expression -> expression PLUS factor .)
    LBRACKET        reduce using rule 18 (expression -> expression PLUS factor .)
    INTEGER         reduce using rule 18 (expression -> expression PLUS factor .)
    FLOAT           reduce using rule 18 (expression -> expression PLUS factor .)
    LPAREN          reduce using rule 18 (expression -> expression PLUS factor .)
    $end            reduce using rule 18 (expression -> expression PLUS factor .)
    RPAREN          reduce using rule 18 (expression -> expression PLUS factor .)
    RBRACKET        reduce using rule 18 (expression -> expression PLUS factor .)
    COMMA           reduce using rule 18 (expression -> expression PLUS factor .)


state 36

    (19) expression -> expression MINUS factor .

    PLUS            reduce using rule 19 (expression -> expression MINUS factor .)
    MINUS           reduce using rule 19 (expression -> expression MINUS factor .)
    END             reduce using rule 19 (expression -> expression MINUS factor .)
    IDENTIFIER      reduce using rule 19 (expression -> expression MINUS factor .)
    INSTANCE_VAR    reduce using rule 19 (expression -> expression MINUS factor .)
    WHILE           reduce using rule 19 (expression -> expression MINUS factor .)
    DEF             reduce using rule 19 (expression -> expression MINUS factor .)
    FOR             reduce using rule 19 (expression -> expression MINUS factor .)
    PUTS            reduce using rule 19 (expression -> expression MINUS factor .)
    SETNEW          reduce using rule 19 (expression -> expression MINUS factor .)
    LBRACKET        reduce using rule 19 (expression -> expression MINUS factor .)
    INTEGER         reduce using rule 19 (expression -> expression MINUS factor .)
    FLOAT           reduce using rule 19 (expression -> expression MINUS factor .)
    LPAREN          reduce using rule 19 (expression -> expression MINUS factor .)
    $end            reduce using rule 19 (expression -> expression MINUS factor .)
    RPAREN          reduce using rule 19 (expression -> expression MINUS factor .)
    RBRACKET        reduce using rule 19 (expression -> expression MINUS factor .)
    COMMA           reduce using rule 19 (expression -> expression MINUS factor .)


state 37

    (8) statement -> IDENTIFIER ASSIGN INTEGER .

    END             reduce using rule 8 (statement -> IDENTIFIER ASSIGN INTEGER .)
    IDENTIFIER      reduce using rule 8 (statement -> IDENTIFIER ASSIGN INTEGER .)
    INSTANCE_VAR    reduce using rule 8 (statement -> IDENTIFIER ASSIGN INTEGER .)
    WHILE           reduce using rule 8 (statement -> IDENTIFIER ASSIGN INTEGER .)
    DEF             reduce using rule 8 (statement -> IDENTIFIER ASSIGN INTEGER .)
    FOR             reduce using rule 8 (statement -> IDENTIFIER ASSIGN INTEGER .)
    PUTS            reduce using rule 8 (statement -> IDENTIFIER ASSIGN INTEGER .)
    SETNEW          reduce using rule 8 (statement -> IDENTIFIER ASSIGN INTEGER .)
    LBRACKET        reduce using rule 8 (statement -> IDENTIFIER ASSIGN INTEGER .)
    INTEGER         reduce using rule 8 (statement -> IDENTIFIER ASSIGN INTEGER .)
    FLOAT           reduce using rule 8 (statement -> IDENTIFIER ASSIGN INTEGER .)
    LPAREN          reduce using rule 8 (statement -> IDENTIFIER ASSIGN INTEGER .)
    $end            reduce using rule 8 (statement -> IDENTIFIER ASSIGN INTEGER .)


state 38

    (9) statement -> IDENTIFIER ASSIGN FLOAT .

    END             reduce using rule 9 (statement -> IDENTIFIER ASSIGN FLOAT .)
    IDENTIFIER      reduce using rule 9 (statement -> IDENTIFIER ASSIGN FLOAT .)
    INSTANCE_VAR    reduce using rule 9 (statement -> IDENTIFIER ASSIGN FLOAT .)
    WHILE           reduce using rule 9 (statement -> IDENTIFIER ASSIGN FLOAT .)
    DEF             reduce using rule 9 (statement -> IDENTIFIER ASSIGN FLOAT .)
    FOR             reduce using rule 9 (statement -> IDENTIFIER ASSIGN FLOAT .)
    PUTS            reduce using rule 9 (statement -> IDENTIFIER ASSIGN FLOAT .)
    SETNEW          reduce using rule 9 (statement -> IDENTIFIER ASSIGN FLOAT .)
    LBRACKET        reduce using rule 9 (statement -> IDENTIFIER ASSIGN FLOAT .)
    INTEGER         reduce using rule 9 (statement -> IDENTIFIER ASSIGN FLOAT .)
    FLOAT           reduce using rule 9 (statement -> IDENTIFIER ASSIGN FLOAT .)
    LPAREN          reduce using rule 9 (statement -> IDENTIFIER ASSIGN FLOAT .)
    $end            reduce using rule 9 (statement -> IDENTIFIER ASSIGN FLOAT .)


state 39

    (14) statement -> IDENTIFIER ASSIGN GETS .

    END             reduce using rule 14 (statement -> IDENTIFIER ASSIGN GETS .)
    IDENTIFIER      reduce using rule 14 (statement -> IDENTIFIER ASSIGN GETS .)
    INSTANCE_VAR    reduce using rule 14 (statement -> IDENTIFIER ASSIGN GETS .)
    WHILE           reduce using rule 14 (statement -> IDENTIFIER ASSIGN GETS .)
    DEF             reduce using rule 14 (statement -> IDENTIFIER ASSIGN GETS .)
    FOR             reduce using rule 14 (statement -> IDENTIFIER ASSIGN GETS .)
    PUTS            reduce using rule 14 (statement -> IDENTIFIER ASSIGN GETS .)
    SETNEW          reduce using rule 14 (statement -> IDENTIFIER ASSIGN GETS .)
    LBRACKET        reduce using rule 14 (statement -> IDENTIFIER ASSIGN GETS .)
    INTEGER         reduce using rule 14 (statement -> IDENTIFIER ASSIGN GETS .)
    FLOAT           reduce using rule 14 (statement -> IDENTIFIER ASSIGN GETS .)
    LPAREN          reduce using rule 14 (statement -> IDENTIFIER ASSIGN GETS .)
    $end            reduce using rule 14 (statement -> IDENTIFIER ASSIGN GETS .)


state 40

    (3) params -> IDENTIFIER .

    RPAREN          reduce using rule 3 (params -> IDENTIFIER .)
    COMMA           reduce using rule 3 (params -> IDENTIFIER .)


state 41

    (27) statement -> IDENTIFIER LPAREN params . RPAREN
    (4) params -> params . COMMA IDENTIFIER

    RPAREN          shift and go to state 53
    COMMA           shift and go to state 54


state 42

    (10) statement -> INSTANCE_VAR ASSIGN INTEGER .

    END             reduce using rule 10 (statement -> INSTANCE_VAR ASSIGN INTEGER .)
    IDENTIFIER      reduce using rule 10 (statement -> INSTANCE_VAR ASSIGN INTEGER .)
    INSTANCE_VAR    reduce using rule 10 (statement -> INSTANCE_VAR ASSIGN INTEGER .)
    WHILE           reduce using rule 10 (statement -> INSTANCE_VAR ASSIGN INTEGER .)
    DEF             reduce using rule 10 (statement -> INSTANCE_VAR ASSIGN INTEGER .)
    FOR             reduce using rule 10 (statement -> INSTANCE_VAR ASSIGN INTEGER .)
    PUTS            reduce using rule 10 (statement -> INSTANCE_VAR ASSIGN INTEGER .)
    SETNEW          reduce using rule 10 (statement -> INSTANCE_VAR ASSIGN INTEGER .)
    LBRACKET        reduce using rule 10 (statement -> INSTANCE_VAR ASSIGN INTEGER .)
    INTEGER         reduce using rule 10 (statement -> INSTANCE_VAR ASSIGN INTEGER .)
    FLOAT           reduce using rule 10 (statement -> INSTANCE_VAR ASSIGN INTEGER .)
    LPAREN          reduce using rule 10 (statement -> INSTANCE_VAR ASSIGN INTEGER .)
    $end            reduce using rule 10 (statement -> INSTANCE_VAR ASSIGN INTEGER .)


state 43

    (11) statement -> INSTANCE_VAR ASSIGN FLOAT .

    END             reduce using rule 11 (statement -> INSTANCE_VAR ASSIGN FLOAT .)
    IDENTIFIER      reduce using rule 11 (statement -> INSTANCE_VAR ASSIGN FLOAT .)
    INSTANCE_VAR    reduce using rule 11 (statement -> INSTANCE_VAR ASSIGN FLOAT .)
    WHILE           reduce using rule 11 (statement -> INSTANCE_VAR ASSIGN FLOAT .)
    DEF             reduce using rule 11 (statement -> INSTANCE_VAR ASSIGN FLOAT .)
    FOR             reduce using rule 11 (statement -> INSTANCE_VAR ASSIGN FLOAT .)
    PUTS            reduce using rule 11 (statement -> INSTANCE_VAR ASSIGN FLOAT .)
    SETNEW          reduce using rule 11 (statement -> INSTANCE_VAR ASSIGN FLOAT .)
    LBRACKET        reduce using rule 11 (statement -> INSTANCE_VAR ASSIGN FLOAT .)
    INTEGER         reduce using rule 11 (statement -> INSTANCE_VAR ASSIGN FLOAT .)
    FLOAT           reduce using rule 11 (statement -> INSTANCE_VAR ASSIGN FLOAT .)
    LPAREN          reduce using rule 11 (statement -> INSTANCE_VAR ASSIGN FLOAT .)
    $end            reduce using rule 11 (statement -> INSTANCE_VAR ASSIGN FLOAT .)


state 44

    (13) statement -> WHILE expression statement . END

    END             shift and go to state 55


state 45

    (26) statement -> DEF IDENTIFIER LPAREN . params RPAREN statement END
    (3) params -> . IDENTIFIER
    (4) params -> . params COMMA IDENTIFIER

    IDENTIFIER      shift and go to state 40

    params                         shift and go to state 56

state 46

    (22) factor -> LPAREN expression RPAREN .

    DIVIDE          reduce using rule 22 (factor -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 22 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 22 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 22 (factor -> LPAREN expression RPAREN .)
    END             reduce using rule 22 (factor -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 22 (factor -> LPAREN expression RPAREN .)
    INSTANCE_VAR    reduce using rule 22 (factor -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 22 (factor -> LPAREN expression RPAREN .)
    DEF             reduce using rule 22 (factor -> LPAREN expression RPAREN .)
    FOR             reduce using rule 22 (factor -> LPAREN expression RPAREN .)
    PUTS            reduce using rule 22 (factor -> LPAREN expression RPAREN .)
    SETNEW          reduce using rule 22 (factor -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 22 (factor -> LPAREN expression RPAREN .)
    INTEGER         reduce using rule 22 (factor -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 22 (factor -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 22 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 22 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 22 (factor -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 22 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 22 (factor -> LPAREN expression RPAREN .)


state 47

    (28) statement -> FOR IDENTIFIER IN . range statement
    (29) range -> . INTEGER DOUBLE_DOT INTEGER
    (30) range -> . FLOAT DOUBLE_DOT FLOAT

    INTEGER         shift and go to state 58
    FLOAT           shift and go to state 59

    range                          shift and go to state 57

state 48

    (12) expression -> SETNEW LPAREN elements . RPAREN
    (25) elements -> elements . COMMA expression

    RPAREN          shift and go to state 60
    COMMA           shift and go to state 52


state 49

    (16) term -> factor DIVIDE factor .

    PLUS            reduce using rule 16 (term -> factor DIVIDE factor .)
    MINUS           reduce using rule 16 (term -> factor DIVIDE factor .)
    END             reduce using rule 16 (term -> factor DIVIDE factor .)
    IDENTIFIER      reduce using rule 16 (term -> factor DIVIDE factor .)
    INSTANCE_VAR    reduce using rule 16 (term -> factor DIVIDE factor .)
    WHILE           reduce using rule 16 (term -> factor DIVIDE factor .)
    DEF             reduce using rule 16 (term -> factor DIVIDE factor .)
    FOR             reduce using rule 16 (term -> factor DIVIDE factor .)
    PUTS            reduce using rule 16 (term -> factor DIVIDE factor .)
    SETNEW          reduce using rule 16 (term -> factor DIVIDE factor .)
    LBRACKET        reduce using rule 16 (term -> factor DIVIDE factor .)
    INTEGER         reduce using rule 16 (term -> factor DIVIDE factor .)
    FLOAT           reduce using rule 16 (term -> factor DIVIDE factor .)
    LPAREN          reduce using rule 16 (term -> factor DIVIDE factor .)
    $end            reduce using rule 16 (term -> factor DIVIDE factor .)
    RPAREN          reduce using rule 16 (term -> factor DIVIDE factor .)
    RBRACKET        reduce using rule 16 (term -> factor DIVIDE factor .)
    COMMA           reduce using rule 16 (term -> factor DIVIDE factor .)


state 50

    (17) term -> factor TIMES factor .

    PLUS            reduce using rule 17 (term -> factor TIMES factor .)
    MINUS           reduce using rule 17 (term -> factor TIMES factor .)
    END             reduce using rule 17 (term -> factor TIMES factor .)
    IDENTIFIER      reduce using rule 17 (term -> factor TIMES factor .)
    INSTANCE_VAR    reduce using rule 17 (term -> factor TIMES factor .)
    WHILE           reduce using rule 17 (term -> factor TIMES factor .)
    DEF             reduce using rule 17 (term -> factor TIMES factor .)
    FOR             reduce using rule 17 (term -> factor TIMES factor .)
    PUTS            reduce using rule 17 (term -> factor TIMES factor .)
    SETNEW          reduce using rule 17 (term -> factor TIMES factor .)
    LBRACKET        reduce using rule 17 (term -> factor TIMES factor .)
    INTEGER         reduce using rule 17 (term -> factor TIMES factor .)
    FLOAT           reduce using rule 17 (term -> factor TIMES factor .)
    LPAREN          reduce using rule 17 (term -> factor TIMES factor .)
    $end            reduce using rule 17 (term -> factor TIMES factor .)
    RPAREN          reduce using rule 17 (term -> factor TIMES factor .)
    RBRACKET        reduce using rule 17 (term -> factor TIMES factor .)
    COMMA           reduce using rule 17 (term -> factor TIMES factor .)


state 51

    (23) expression -> LBRACKET elements RBRACKET .

    PLUS            reduce using rule 23 (expression -> LBRACKET elements RBRACKET .)
    MINUS           reduce using rule 23 (expression -> LBRACKET elements RBRACKET .)
    END             reduce using rule 23 (expression -> LBRACKET elements RBRACKET .)
    IDENTIFIER      reduce using rule 23 (expression -> LBRACKET elements RBRACKET .)
    INSTANCE_VAR    reduce using rule 23 (expression -> LBRACKET elements RBRACKET .)
    WHILE           reduce using rule 23 (expression -> LBRACKET elements RBRACKET .)
    DEF             reduce using rule 23 (expression -> LBRACKET elements RBRACKET .)
    FOR             reduce using rule 23 (expression -> LBRACKET elements RBRACKET .)
    PUTS            reduce using rule 23 (expression -> LBRACKET elements RBRACKET .)
    SETNEW          reduce using rule 23 (expression -> LBRACKET elements RBRACKET .)
    LBRACKET        reduce using rule 23 (expression -> LBRACKET elements RBRACKET .)
    INTEGER         reduce using rule 23 (expression -> LBRACKET elements RBRACKET .)
    FLOAT           reduce using rule 23 (expression -> LBRACKET elements RBRACKET .)
    LPAREN          reduce using rule 23 (expression -> LBRACKET elements RBRACKET .)
    $end            reduce using rule 23 (expression -> LBRACKET elements RBRACKET .)
    RPAREN          reduce using rule 23 (expression -> LBRACKET elements RBRACKET .)
    RBRACKET        reduce using rule 23 (expression -> LBRACKET elements RBRACKET .)
    COMMA           reduce using rule 23 (expression -> LBRACKET elements RBRACKET .)


state 52

    (25) elements -> elements COMMA . expression
    (12) expression -> . SETNEW LPAREN elements RPAREN
    (15) expression -> . term
    (18) expression -> . expression PLUS factor
    (19) expression -> . expression MINUS factor
    (23) expression -> . LBRACKET elements RBRACKET
    (16) term -> . factor DIVIDE factor
    (17) term -> . factor TIMES factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . LPAREN expression RPAREN

    SETNEW          shift and go to state 14
    LBRACKET        shift and go to state 17
    INTEGER         shift and go to state 6
    FLOAT           shift and go to state 7
    LPAREN          shift and go to state 11

    expression                     shift and go to state 61
    term                           shift and go to state 15
    factor                         shift and go to state 16

state 53

    (27) statement -> IDENTIFIER LPAREN params RPAREN .

    END             reduce using rule 27 (statement -> IDENTIFIER LPAREN params RPAREN .)
    IDENTIFIER      reduce using rule 27 (statement -> IDENTIFIER LPAREN params RPAREN .)
    INSTANCE_VAR    reduce using rule 27 (statement -> IDENTIFIER LPAREN params RPAREN .)
    WHILE           reduce using rule 27 (statement -> IDENTIFIER LPAREN params RPAREN .)
    DEF             reduce using rule 27 (statement -> IDENTIFIER LPAREN params RPAREN .)
    FOR             reduce using rule 27 (statement -> IDENTIFIER LPAREN params RPAREN .)
    PUTS            reduce using rule 27 (statement -> IDENTIFIER LPAREN params RPAREN .)
    SETNEW          reduce using rule 27 (statement -> IDENTIFIER LPAREN params RPAREN .)
    LBRACKET        reduce using rule 27 (statement -> IDENTIFIER LPAREN params RPAREN .)
    INTEGER         reduce using rule 27 (statement -> IDENTIFIER LPAREN params RPAREN .)
    FLOAT           reduce using rule 27 (statement -> IDENTIFIER LPAREN params RPAREN .)
    LPAREN          reduce using rule 27 (statement -> IDENTIFIER LPAREN params RPAREN .)
    $end            reduce using rule 27 (statement -> IDENTIFIER LPAREN params RPAREN .)


state 54

    (4) params -> params COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 62


state 55

    (13) statement -> WHILE expression statement END .

    END             reduce using rule 13 (statement -> WHILE expression statement END .)
    IDENTIFIER      reduce using rule 13 (statement -> WHILE expression statement END .)
    INSTANCE_VAR    reduce using rule 13 (statement -> WHILE expression statement END .)
    WHILE           reduce using rule 13 (statement -> WHILE expression statement END .)
    DEF             reduce using rule 13 (statement -> WHILE expression statement END .)
    FOR             reduce using rule 13 (statement -> WHILE expression statement END .)
    PUTS            reduce using rule 13 (statement -> WHILE expression statement END .)
    SETNEW          reduce using rule 13 (statement -> WHILE expression statement END .)
    LBRACKET        reduce using rule 13 (statement -> WHILE expression statement END .)
    INTEGER         reduce using rule 13 (statement -> WHILE expression statement END .)
    FLOAT           reduce using rule 13 (statement -> WHILE expression statement END .)
    LPAREN          reduce using rule 13 (statement -> WHILE expression statement END .)
    $end            reduce using rule 13 (statement -> WHILE expression statement END .)


state 56

    (26) statement -> DEF IDENTIFIER LPAREN params . RPAREN statement END
    (4) params -> params . COMMA IDENTIFIER

    RPAREN          shift and go to state 63
    COMMA           shift and go to state 54


state 57

    (28) statement -> FOR IDENTIFIER IN range . statement
    (7) statement -> . expression
    (8) statement -> . IDENTIFIER ASSIGN INTEGER
    (9) statement -> . IDENTIFIER ASSIGN FLOAT
    (10) statement -> . INSTANCE_VAR ASSIGN INTEGER
    (11) statement -> . INSTANCE_VAR ASSIGN FLOAT
    (13) statement -> . WHILE expression statement END
    (14) statement -> . IDENTIFIER ASSIGN GETS
    (26) statement -> . DEF IDENTIFIER LPAREN params RPAREN statement END
    (27) statement -> . IDENTIFIER LPAREN params RPAREN
    (28) statement -> . FOR IDENTIFIER IN range statement
    (31) statement -> . PUTS statement
    (12) expression -> . SETNEW LPAREN elements RPAREN
    (15) expression -> . term
    (18) expression -> . expression PLUS factor
    (19) expression -> . expression MINUS factor
    (23) expression -> . LBRACKET elements RBRACKET
    (16) term -> . factor DIVIDE factor
    (17) term -> . factor TIMES factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 5
    INSTANCE_VAR    shift and go to state 8
    WHILE           shift and go to state 9
    DEF             shift and go to state 10
    FOR             shift and go to state 12
    PUTS            shift and go to state 13
    SETNEW          shift and go to state 14
    LBRACKET        shift and go to state 17
    INTEGER         shift and go to state 6
    FLOAT           shift and go to state 7
    LPAREN          shift and go to state 11

    statement                      shift and go to state 64
    expression                     shift and go to state 4
    term                           shift and go to state 15
    factor                         shift and go to state 16

state 58

    (29) range -> INTEGER . DOUBLE_DOT INTEGER

    DOUBLE_DOT      shift and go to state 65


state 59

    (30) range -> FLOAT . DOUBLE_DOT FLOAT

    DOUBLE_DOT      shift and go to state 66


state 60

    (12) expression -> SETNEW LPAREN elements RPAREN .

    PLUS            reduce using rule 12 (expression -> SETNEW LPAREN elements RPAREN .)
    MINUS           reduce using rule 12 (expression -> SETNEW LPAREN elements RPAREN .)
    END             reduce using rule 12 (expression -> SETNEW LPAREN elements RPAREN .)
    IDENTIFIER      reduce using rule 12 (expression -> SETNEW LPAREN elements RPAREN .)
    INSTANCE_VAR    reduce using rule 12 (expression -> SETNEW LPAREN elements RPAREN .)
    WHILE           reduce using rule 12 (expression -> SETNEW LPAREN elements RPAREN .)
    DEF             reduce using rule 12 (expression -> SETNEW LPAREN elements RPAREN .)
    FOR             reduce using rule 12 (expression -> SETNEW LPAREN elements RPAREN .)
    PUTS            reduce using rule 12 (expression -> SETNEW LPAREN elements RPAREN .)
    SETNEW          reduce using rule 12 (expression -> SETNEW LPAREN elements RPAREN .)
    LBRACKET        reduce using rule 12 (expression -> SETNEW LPAREN elements RPAREN .)
    INTEGER         reduce using rule 12 (expression -> SETNEW LPAREN elements RPAREN .)
    FLOAT           reduce using rule 12 (expression -> SETNEW LPAREN elements RPAREN .)
    LPAREN          reduce using rule 12 (expression -> SETNEW LPAREN elements RPAREN .)
    $end            reduce using rule 12 (expression -> SETNEW LPAREN elements RPAREN .)
    RPAREN          reduce using rule 12 (expression -> SETNEW LPAREN elements RPAREN .)
    RBRACKET        reduce using rule 12 (expression -> SETNEW LPAREN elements RPAREN .)
    COMMA           reduce using rule 12 (expression -> SETNEW LPAREN elements RPAREN .)


state 61

    (25) elements -> elements COMMA expression .
    (18) expression -> expression . PLUS factor
    (19) expression -> expression . MINUS factor

    RBRACKET        reduce using rule 25 (elements -> elements COMMA expression .)
    COMMA           reduce using rule 25 (elements -> elements COMMA expression .)
    RPAREN          reduce using rule 25 (elements -> elements COMMA expression .)
    PLUS            shift and go to state 20
    MINUS           shift and go to state 21


state 62

    (4) params -> params COMMA IDENTIFIER .

    RPAREN          reduce using rule 4 (params -> params COMMA IDENTIFIER .)
    COMMA           reduce using rule 4 (params -> params COMMA IDENTIFIER .)


state 63

    (26) statement -> DEF IDENTIFIER LPAREN params RPAREN . statement END
    (7) statement -> . expression
    (8) statement -> . IDENTIFIER ASSIGN INTEGER
    (9) statement -> . IDENTIFIER ASSIGN FLOAT
    (10) statement -> . INSTANCE_VAR ASSIGN INTEGER
    (11) statement -> . INSTANCE_VAR ASSIGN FLOAT
    (13) statement -> . WHILE expression statement END
    (14) statement -> . IDENTIFIER ASSIGN GETS
    (26) statement -> . DEF IDENTIFIER LPAREN params RPAREN statement END
    (27) statement -> . IDENTIFIER LPAREN params RPAREN
    (28) statement -> . FOR IDENTIFIER IN range statement
    (31) statement -> . PUTS statement
    (12) expression -> . SETNEW LPAREN elements RPAREN
    (15) expression -> . term
    (18) expression -> . expression PLUS factor
    (19) expression -> . expression MINUS factor
    (23) expression -> . LBRACKET elements RBRACKET
    (16) term -> . factor DIVIDE factor
    (17) term -> . factor TIMES factor
    (20) factor -> . INTEGER
    (21) factor -> . FLOAT
    (22) factor -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 5
    INSTANCE_VAR    shift and go to state 8
    WHILE           shift and go to state 9
    DEF             shift and go to state 10
    FOR             shift and go to state 12
    PUTS            shift and go to state 13
    SETNEW          shift and go to state 14
    LBRACKET        shift and go to state 17
    INTEGER         shift and go to state 6
    FLOAT           shift and go to state 7
    LPAREN          shift and go to state 11

    statement                      shift and go to state 67
    expression                     shift and go to state 4
    term                           shift and go to state 15
    factor                         shift and go to state 16

state 64

    (28) statement -> FOR IDENTIFIER IN range statement .

    END             reduce using rule 28 (statement -> FOR IDENTIFIER IN range statement .)
    IDENTIFIER      reduce using rule 28 (statement -> FOR IDENTIFIER IN range statement .)
    INSTANCE_VAR    reduce using rule 28 (statement -> FOR IDENTIFIER IN range statement .)
    WHILE           reduce using rule 28 (statement -> FOR IDENTIFIER IN range statement .)
    DEF             reduce using rule 28 (statement -> FOR IDENTIFIER IN range statement .)
    FOR             reduce using rule 28 (statement -> FOR IDENTIFIER IN range statement .)
    PUTS            reduce using rule 28 (statement -> FOR IDENTIFIER IN range statement .)
    SETNEW          reduce using rule 28 (statement -> FOR IDENTIFIER IN range statement .)
    LBRACKET        reduce using rule 28 (statement -> FOR IDENTIFIER IN range statement .)
    INTEGER         reduce using rule 28 (statement -> FOR IDENTIFIER IN range statement .)
    FLOAT           reduce using rule 28 (statement -> FOR IDENTIFIER IN range statement .)
    LPAREN          reduce using rule 28 (statement -> FOR IDENTIFIER IN range statement .)
    $end            reduce using rule 28 (statement -> FOR IDENTIFIER IN range statement .)


state 65

    (29) range -> INTEGER DOUBLE_DOT . INTEGER

    INTEGER         shift and go to state 68


state 66

    (30) range -> FLOAT DOUBLE_DOT . FLOAT

    FLOAT           shift and go to state 69


state 67

    (26) statement -> DEF IDENTIFIER LPAREN params RPAREN statement . END

    END             shift and go to state 70


state 68

    (29) range -> INTEGER DOUBLE_DOT INTEGER .

    IDENTIFIER      reduce using rule 29 (range -> INTEGER DOUBLE_DOT INTEGER .)
    INSTANCE_VAR    reduce using rule 29 (range -> INTEGER DOUBLE_DOT INTEGER .)
    WHILE           reduce using rule 29 (range -> INTEGER DOUBLE_DOT INTEGER .)
    DEF             reduce using rule 29 (range -> INTEGER DOUBLE_DOT INTEGER .)
    FOR             reduce using rule 29 (range -> INTEGER DOUBLE_DOT INTEGER .)
    PUTS            reduce using rule 29 (range -> INTEGER DOUBLE_DOT INTEGER .)
    SETNEW          reduce using rule 29 (range -> INTEGER DOUBLE_DOT INTEGER .)
    LBRACKET        reduce using rule 29 (range -> INTEGER DOUBLE_DOT INTEGER .)
    INTEGER         reduce using rule 29 (range -> INTEGER DOUBLE_DOT INTEGER .)
    FLOAT           reduce using rule 29 (range -> INTEGER DOUBLE_DOT INTEGER .)
    LPAREN          reduce using rule 29 (range -> INTEGER DOUBLE_DOT INTEGER .)


state 69

    (30) range -> FLOAT DOUBLE_DOT FLOAT .

    IDENTIFIER      reduce using rule 30 (range -> FLOAT DOUBLE_DOT FLOAT .)
    INSTANCE_VAR    reduce using rule 30 (range -> FLOAT DOUBLE_DOT FLOAT .)
    WHILE           reduce using rule 30 (range -> FLOAT DOUBLE_DOT FLOAT .)
    DEF             reduce using rule 30 (range -> FLOAT DOUBLE_DOT FLOAT .)
    FOR             reduce using rule 30 (range -> FLOAT DOUBLE_DOT FLOAT .)
    PUTS            reduce using rule 30 (range -> FLOAT DOUBLE_DOT FLOAT .)
    SETNEW          reduce using rule 30 (range -> FLOAT DOUBLE_DOT FLOAT .)
    LBRACKET        reduce using rule 30 (range -> FLOAT DOUBLE_DOT FLOAT .)
    INTEGER         reduce using rule 30 (range -> FLOAT DOUBLE_DOT FLOAT .)
    FLOAT           reduce using rule 30 (range -> FLOAT DOUBLE_DOT FLOAT .)
    LPAREN          reduce using rule 30 (range -> FLOAT DOUBLE_DOT FLOAT .)


state 70

    (26) statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .

    END             reduce using rule 26 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    IDENTIFIER      reduce using rule 26 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    INSTANCE_VAR    reduce using rule 26 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    WHILE           reduce using rule 26 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    DEF             reduce using rule 26 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    FOR             reduce using rule 26 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    PUTS            reduce using rule 26 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    SETNEW          reduce using rule 26 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    LBRACKET        reduce using rule 26 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    INTEGER         reduce using rule 26 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    FLOAT           reduce using rule 26 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    LPAREN          reduce using rule 26 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    $end            reduce using rule 26 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)

