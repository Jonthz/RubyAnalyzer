Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    BEGIN
    BITWISE_AND
    BREAK
    CASE
    CLASS
    CLASS_VAR
    COMMENT
    CONSTANT
    DIVIDE_ASSIGN
    DO
    DOT
    ELSE
    ELSIF
    ENSURE
    EQUALS
    FALSE
    FLOOR_DIVIDE
    GLOBAL_VAR
    GREATER
    GREATER_EQUAL
    IF
    LAMBDA
    LBRACE
    LESS
    LESS_EQUAL
    MINUS_ASSIGN
    MOD
    MODULE
    MOD_ASSIGN
    NEXT
    NIL
    NOT
    NOT_EQUALS
    OR
    PIPE
    PLUS_ASSIGN
    POWER
    POWER_ASSIGN
    PROC
    QUESTION_MARK
    RAISE
    RANGE
    RBRACE
    REDO
    REQUIRE
    RESCUE
    RETRY
    RETURN
    SELF
    SEMICOLON
    SPACESHIP
    STRING
    SUPER
    TIMES_ASSIGN
    TRUE
    UNTIL
    WHEN
    YIELD

Grammar

Rule 0     S' -> program
Rule 1     program -> statements END
Rule 2     program -> statements
Rule 3     params -> IDENTIFIER
Rule 4     params -> params COMMA IDENTIFIER
Rule 5     statements -> statement
Rule 6     statements -> statements statement
Rule 7     statement -> expression
Rule 8     statement -> IDENTIFIER ASSIGN expression
Rule 9     statement -> INSTANCE_VAR ASSIGN expression
Rule 10    statement -> SETNEW LPAREN optional_elements RPAREN
Rule 11    optional_elements -> elements
Rule 12    optional_elements -> empty
Rule 13    empty -> <empty>
Rule 14    statement -> WHILE expression statement END
Rule 15    statement -> IDENTIFIER ASSIGN GETS
Rule 16    statement -> DEF IDENTIFIER LPAREN params RPAREN statement END
Rule 17    statement -> IDENTIFIER LPAREN params RPAREN
Rule 18    expression -> term
Rule 19    term -> factor DIVIDE factor
Rule 20    term -> factor TIMES factor
Rule 21    expression -> factor PLUS factor
Rule 22    expression -> factor MINUS factor
Rule 23    factor -> INTEGER
Rule 24    factor -> FLOAT
Rule 25    factor -> LPAREN expression RPAREN
Rule 26    expression -> LBRACKET elements RBRACKET
Rule 27    elements -> expression
Rule 28    elements -> elements COMMA expression
Rule 29    statement -> FOR IDENTIFIER IN range statement
Rule 30    range -> INTEGER DOUBLE_DOT INTEGER
Rule 31    range -> FLOAT DOUBLE_DOT FLOAT
Rule 32    statement -> PUTS statement

Terminals, with rules where they appear

AND                  : 
ASSIGN               : 8 9 15
BEGIN                : 
BITWISE_AND          : 
BREAK                : 
CASE                 : 
CLASS                : 
CLASS_VAR            : 
COMMA                : 4 28
COMMENT              : 
CONSTANT             : 
DEF                  : 16
DIVIDE               : 19
DIVIDE_ASSIGN        : 
DO                   : 
DOT                  : 
DOUBLE_DOT           : 30 31
ELSE                 : 
ELSIF                : 
END                  : 1 14 16
ENSURE               : 
EQUALS               : 
FALSE                : 
FLOAT                : 24 31 31
FLOOR_DIVIDE         : 
FOR                  : 29
GETS                 : 15
GLOBAL_VAR           : 
GREATER              : 
GREATER_EQUAL        : 
IDENTIFIER           : 3 4 8 15 16 17 29
IF                   : 
IN                   : 29
INSTANCE_VAR         : 9
INTEGER              : 23 30 30
LAMBDA               : 
LBRACE               : 
LBRACKET             : 26
LESS                 : 
LESS_EQUAL           : 
LPAREN               : 10 16 17 25
MINUS                : 22
MINUS_ASSIGN         : 
MOD                  : 
MODULE               : 
MOD_ASSIGN           : 
NEXT                 : 
NIL                  : 
NOT                  : 
NOT_EQUALS           : 
OR                   : 
PIPE                 : 
PLUS                 : 21
PLUS_ASSIGN          : 
POWER                : 
POWER_ASSIGN         : 
PROC                 : 
PUTS                 : 32
QUESTION_MARK        : 
RAISE                : 
RANGE                : 
RBRACE               : 
RBRACKET             : 26
REDO                 : 
REQUIRE              : 
RESCUE               : 
RETRY                : 
RETURN               : 
RPAREN               : 10 16 17 25
SELF                 : 
SEMICOLON            : 
SETNEW               : 10
SPACESHIP            : 
STRING               : 
SUPER                : 
TIMES                : 20
TIMES_ASSIGN         : 
TRUE                 : 
UNTIL                : 
WHEN                 : 
WHILE                : 14
YIELD                : 
error                : 

Nonterminals, with rules where they appear

elements             : 11 26 28
empty                : 12
expression           : 7 8 9 14 25 27 28
factor               : 19 19 20 20 21 21 22 22
optional_elements    : 10
params               : 4 16 17
program              : 0
range                : 29
statement            : 5 6 14 16 29 32
statements           : 1 2 6
term                 : 18

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statements END
    (2) program -> . statements
    (5) statements -> . statement
    (6) statements -> . statements statement
    (7) statement -> . expression
    (8) statement -> . IDENTIFIER ASSIGN expression
    (9) statement -> . INSTANCE_VAR ASSIGN expression
    (10) statement -> . SETNEW LPAREN optional_elements RPAREN
    (14) statement -> . WHILE expression statement END
    (15) statement -> . IDENTIFIER ASSIGN GETS
    (16) statement -> . DEF IDENTIFIER LPAREN params RPAREN statement END
    (17) statement -> . IDENTIFIER LPAREN params RPAREN
    (29) statement -> . FOR IDENTIFIER IN range statement
    (32) statement -> . PUTS statement
    (18) expression -> . term
    (21) expression -> . factor PLUS factor
    (22) expression -> . factor MINUS factor
    (26) expression -> . LBRACKET elements RBRACKET
    (19) term -> . factor DIVIDE factor
    (20) term -> . factor TIMES factor
    (23) factor -> . INTEGER
    (24) factor -> . FLOAT
    (25) factor -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 5
    INSTANCE_VAR    shift and go to state 6
    SETNEW          shift and go to state 7
    WHILE           shift and go to state 9
    DEF             shift and go to state 10
    FOR             shift and go to state 11
    PUTS            shift and go to state 12
    LBRACKET        shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    LPAREN          shift and go to state 8

    program                        shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    term                           shift and go to state 13
    factor                         shift and go to state 14

state 1

    (0) S' -> program .



state 2

    (1) program -> statements . END
    (2) program -> statements .
    (6) statements -> statements . statement
    (7) statement -> . expression
    (8) statement -> . IDENTIFIER ASSIGN expression
    (9) statement -> . INSTANCE_VAR ASSIGN expression
    (10) statement -> . SETNEW LPAREN optional_elements RPAREN
    (14) statement -> . WHILE expression statement END
    (15) statement -> . IDENTIFIER ASSIGN GETS
    (16) statement -> . DEF IDENTIFIER LPAREN params RPAREN statement END
    (17) statement -> . IDENTIFIER LPAREN params RPAREN
    (29) statement -> . FOR IDENTIFIER IN range statement
    (32) statement -> . PUTS statement
    (18) expression -> . term
    (21) expression -> . factor PLUS factor
    (22) expression -> . factor MINUS factor
    (26) expression -> . LBRACKET elements RBRACKET
    (19) term -> . factor DIVIDE factor
    (20) term -> . factor TIMES factor
    (23) factor -> . INTEGER
    (24) factor -> . FLOAT
    (25) factor -> . LPAREN expression RPAREN

    END             shift and go to state 18
    $end            reduce using rule 2 (program -> statements .)
    IDENTIFIER      shift and go to state 5
    INSTANCE_VAR    shift and go to state 6
    SETNEW          shift and go to state 7
    WHILE           shift and go to state 9
    DEF             shift and go to state 10
    FOR             shift and go to state 11
    PUTS            shift and go to state 12
    LBRACKET        shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    LPAREN          shift and go to state 8

    statement                      shift and go to state 19
    expression                     shift and go to state 4
    term                           shift and go to state 13
    factor                         shift and go to state 14

state 3

    (5) statements -> statement .

    END             reduce using rule 5 (statements -> statement .)
    IDENTIFIER      reduce using rule 5 (statements -> statement .)
    INSTANCE_VAR    reduce using rule 5 (statements -> statement .)
    SETNEW          reduce using rule 5 (statements -> statement .)
    WHILE           reduce using rule 5 (statements -> statement .)
    DEF             reduce using rule 5 (statements -> statement .)
    FOR             reduce using rule 5 (statements -> statement .)
    PUTS            reduce using rule 5 (statements -> statement .)
    LBRACKET        reduce using rule 5 (statements -> statement .)
    INTEGER         reduce using rule 5 (statements -> statement .)
    FLOAT           reduce using rule 5 (statements -> statement .)
    LPAREN          reduce using rule 5 (statements -> statement .)
    $end            reduce using rule 5 (statements -> statement .)


state 4

    (7) statement -> expression .

    END             reduce using rule 7 (statement -> expression .)
    IDENTIFIER      reduce using rule 7 (statement -> expression .)
    INSTANCE_VAR    reduce using rule 7 (statement -> expression .)
    SETNEW          reduce using rule 7 (statement -> expression .)
    WHILE           reduce using rule 7 (statement -> expression .)
    DEF             reduce using rule 7 (statement -> expression .)
    FOR             reduce using rule 7 (statement -> expression .)
    PUTS            reduce using rule 7 (statement -> expression .)
    LBRACKET        reduce using rule 7 (statement -> expression .)
    INTEGER         reduce using rule 7 (statement -> expression .)
    FLOAT           reduce using rule 7 (statement -> expression .)
    LPAREN          reduce using rule 7 (statement -> expression .)
    $end            reduce using rule 7 (statement -> expression .)


state 5

    (8) statement -> IDENTIFIER . ASSIGN expression
    (15) statement -> IDENTIFIER . ASSIGN GETS
    (17) statement -> IDENTIFIER . LPAREN params RPAREN

    ASSIGN          shift and go to state 20
    LPAREN          shift and go to state 21


state 6

    (9) statement -> INSTANCE_VAR . ASSIGN expression

    ASSIGN          shift and go to state 22


state 7

    (10) statement -> SETNEW . LPAREN optional_elements RPAREN

    LPAREN          shift and go to state 23


state 8

    (25) factor -> LPAREN . expression RPAREN
    (18) expression -> . term
    (21) expression -> . factor PLUS factor
    (22) expression -> . factor MINUS factor
    (26) expression -> . LBRACKET elements RBRACKET
    (19) term -> . factor DIVIDE factor
    (20) term -> . factor TIMES factor
    (23) factor -> . INTEGER
    (24) factor -> . FLOAT
    (25) factor -> . LPAREN expression RPAREN

    LBRACKET        shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    LPAREN          shift and go to state 8

    expression                     shift and go to state 24
    term                           shift and go to state 13
    factor                         shift and go to state 14

state 9

    (14) statement -> WHILE . expression statement END
    (18) expression -> . term
    (21) expression -> . factor PLUS factor
    (22) expression -> . factor MINUS factor
    (26) expression -> . LBRACKET elements RBRACKET
    (19) term -> . factor DIVIDE factor
    (20) term -> . factor TIMES factor
    (23) factor -> . INTEGER
    (24) factor -> . FLOAT
    (25) factor -> . LPAREN expression RPAREN

    LBRACKET        shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    LPAREN          shift and go to state 8

    expression                     shift and go to state 25
    term                           shift and go to state 13
    factor                         shift and go to state 14

state 10

    (16) statement -> DEF . IDENTIFIER LPAREN params RPAREN statement END

    IDENTIFIER      shift and go to state 26


state 11

    (29) statement -> FOR . IDENTIFIER IN range statement

    IDENTIFIER      shift and go to state 27


state 12

    (32) statement -> PUTS . statement
    (7) statement -> . expression
    (8) statement -> . IDENTIFIER ASSIGN expression
    (9) statement -> . INSTANCE_VAR ASSIGN expression
    (10) statement -> . SETNEW LPAREN optional_elements RPAREN
    (14) statement -> . WHILE expression statement END
    (15) statement -> . IDENTIFIER ASSIGN GETS
    (16) statement -> . DEF IDENTIFIER LPAREN params RPAREN statement END
    (17) statement -> . IDENTIFIER LPAREN params RPAREN
    (29) statement -> . FOR IDENTIFIER IN range statement
    (32) statement -> . PUTS statement
    (18) expression -> . term
    (21) expression -> . factor PLUS factor
    (22) expression -> . factor MINUS factor
    (26) expression -> . LBRACKET elements RBRACKET
    (19) term -> . factor DIVIDE factor
    (20) term -> . factor TIMES factor
    (23) factor -> . INTEGER
    (24) factor -> . FLOAT
    (25) factor -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 5
    INSTANCE_VAR    shift and go to state 6
    SETNEW          shift and go to state 7
    WHILE           shift and go to state 9
    DEF             shift and go to state 10
    FOR             shift and go to state 11
    PUTS            shift and go to state 12
    LBRACKET        shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    LPAREN          shift and go to state 8

    statement                      shift and go to state 28
    expression                     shift and go to state 4
    term                           shift and go to state 13
    factor                         shift and go to state 14

state 13

    (18) expression -> term .

    END             reduce using rule 18 (expression -> term .)
    IDENTIFIER      reduce using rule 18 (expression -> term .)
    INSTANCE_VAR    reduce using rule 18 (expression -> term .)
    SETNEW          reduce using rule 18 (expression -> term .)
    WHILE           reduce using rule 18 (expression -> term .)
    DEF             reduce using rule 18 (expression -> term .)
    FOR             reduce using rule 18 (expression -> term .)
    PUTS            reduce using rule 18 (expression -> term .)
    LBRACKET        reduce using rule 18 (expression -> term .)
    INTEGER         reduce using rule 18 (expression -> term .)
    FLOAT           reduce using rule 18 (expression -> term .)
    LPAREN          reduce using rule 18 (expression -> term .)
    $end            reduce using rule 18 (expression -> term .)
    RPAREN          reduce using rule 18 (expression -> term .)
    RBRACKET        reduce using rule 18 (expression -> term .)
    COMMA           reduce using rule 18 (expression -> term .)


state 14

    (21) expression -> factor . PLUS factor
    (22) expression -> factor . MINUS factor
    (19) term -> factor . DIVIDE factor
    (20) term -> factor . TIMES factor

    PLUS            shift and go to state 29
    MINUS           shift and go to state 30
    DIVIDE          shift and go to state 31
    TIMES           shift and go to state 32


state 15

    (26) expression -> LBRACKET . elements RBRACKET
    (27) elements -> . expression
    (28) elements -> . elements COMMA expression
    (18) expression -> . term
    (21) expression -> . factor PLUS factor
    (22) expression -> . factor MINUS factor
    (26) expression -> . LBRACKET elements RBRACKET
    (19) term -> . factor DIVIDE factor
    (20) term -> . factor TIMES factor
    (23) factor -> . INTEGER
    (24) factor -> . FLOAT
    (25) factor -> . LPAREN expression RPAREN

    LBRACKET        shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    LPAREN          shift and go to state 8

    elements                       shift and go to state 33
    expression                     shift and go to state 34
    term                           shift and go to state 13
    factor                         shift and go to state 14

state 16

    (23) factor -> INTEGER .

    PLUS            reduce using rule 23 (factor -> INTEGER .)
    MINUS           reduce using rule 23 (factor -> INTEGER .)
    DIVIDE          reduce using rule 23 (factor -> INTEGER .)
    TIMES           reduce using rule 23 (factor -> INTEGER .)
    END             reduce using rule 23 (factor -> INTEGER .)
    IDENTIFIER      reduce using rule 23 (factor -> INTEGER .)
    INSTANCE_VAR    reduce using rule 23 (factor -> INTEGER .)
    SETNEW          reduce using rule 23 (factor -> INTEGER .)
    WHILE           reduce using rule 23 (factor -> INTEGER .)
    DEF             reduce using rule 23 (factor -> INTEGER .)
    FOR             reduce using rule 23 (factor -> INTEGER .)
    PUTS            reduce using rule 23 (factor -> INTEGER .)
    LBRACKET        reduce using rule 23 (factor -> INTEGER .)
    INTEGER         reduce using rule 23 (factor -> INTEGER .)
    FLOAT           reduce using rule 23 (factor -> INTEGER .)
    LPAREN          reduce using rule 23 (factor -> INTEGER .)
    $end            reduce using rule 23 (factor -> INTEGER .)
    RPAREN          reduce using rule 23 (factor -> INTEGER .)
    RBRACKET        reduce using rule 23 (factor -> INTEGER .)
    COMMA           reduce using rule 23 (factor -> INTEGER .)


state 17

    (24) factor -> FLOAT .

    PLUS            reduce using rule 24 (factor -> FLOAT .)
    MINUS           reduce using rule 24 (factor -> FLOAT .)
    DIVIDE          reduce using rule 24 (factor -> FLOAT .)
    TIMES           reduce using rule 24 (factor -> FLOAT .)
    END             reduce using rule 24 (factor -> FLOAT .)
    IDENTIFIER      reduce using rule 24 (factor -> FLOAT .)
    INSTANCE_VAR    reduce using rule 24 (factor -> FLOAT .)
    SETNEW          reduce using rule 24 (factor -> FLOAT .)
    WHILE           reduce using rule 24 (factor -> FLOAT .)
    DEF             reduce using rule 24 (factor -> FLOAT .)
    FOR             reduce using rule 24 (factor -> FLOAT .)
    PUTS            reduce using rule 24 (factor -> FLOAT .)
    LBRACKET        reduce using rule 24 (factor -> FLOAT .)
    INTEGER         reduce using rule 24 (factor -> FLOAT .)
    FLOAT           reduce using rule 24 (factor -> FLOAT .)
    LPAREN          reduce using rule 24 (factor -> FLOAT .)
    $end            reduce using rule 24 (factor -> FLOAT .)
    RPAREN          reduce using rule 24 (factor -> FLOAT .)
    RBRACKET        reduce using rule 24 (factor -> FLOAT .)
    COMMA           reduce using rule 24 (factor -> FLOAT .)


state 18

    (1) program -> statements END .

    $end            reduce using rule 1 (program -> statements END .)


state 19

    (6) statements -> statements statement .

    END             reduce using rule 6 (statements -> statements statement .)
    IDENTIFIER      reduce using rule 6 (statements -> statements statement .)
    INSTANCE_VAR    reduce using rule 6 (statements -> statements statement .)
    SETNEW          reduce using rule 6 (statements -> statements statement .)
    WHILE           reduce using rule 6 (statements -> statements statement .)
    DEF             reduce using rule 6 (statements -> statements statement .)
    FOR             reduce using rule 6 (statements -> statements statement .)
    PUTS            reduce using rule 6 (statements -> statements statement .)
    LBRACKET        reduce using rule 6 (statements -> statements statement .)
    INTEGER         reduce using rule 6 (statements -> statements statement .)
    FLOAT           reduce using rule 6 (statements -> statements statement .)
    LPAREN          reduce using rule 6 (statements -> statements statement .)
    $end            reduce using rule 6 (statements -> statements statement .)


state 20

    (8) statement -> IDENTIFIER ASSIGN . expression
    (15) statement -> IDENTIFIER ASSIGN . GETS
    (18) expression -> . term
    (21) expression -> . factor PLUS factor
    (22) expression -> . factor MINUS factor
    (26) expression -> . LBRACKET elements RBRACKET
    (19) term -> . factor DIVIDE factor
    (20) term -> . factor TIMES factor
    (23) factor -> . INTEGER
    (24) factor -> . FLOAT
    (25) factor -> . LPAREN expression RPAREN

    GETS            shift and go to state 36
    LBRACKET        shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    LPAREN          shift and go to state 8

    expression                     shift and go to state 35
    term                           shift and go to state 13
    factor                         shift and go to state 14

state 21

    (17) statement -> IDENTIFIER LPAREN . params RPAREN
    (3) params -> . IDENTIFIER
    (4) params -> . params COMMA IDENTIFIER

    IDENTIFIER      shift and go to state 37

    params                         shift and go to state 38

state 22

    (9) statement -> INSTANCE_VAR ASSIGN . expression
    (18) expression -> . term
    (21) expression -> . factor PLUS factor
    (22) expression -> . factor MINUS factor
    (26) expression -> . LBRACKET elements RBRACKET
    (19) term -> . factor DIVIDE factor
    (20) term -> . factor TIMES factor
    (23) factor -> . INTEGER
    (24) factor -> . FLOAT
    (25) factor -> . LPAREN expression RPAREN

    LBRACKET        shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    LPAREN          shift and go to state 8

    expression                     shift and go to state 39
    term                           shift and go to state 13
    factor                         shift and go to state 14

state 23

    (10) statement -> SETNEW LPAREN . optional_elements RPAREN
    (11) optional_elements -> . elements
    (12) optional_elements -> . empty
    (27) elements -> . expression
    (28) elements -> . elements COMMA expression
    (13) empty -> .
    (18) expression -> . term
    (21) expression -> . factor PLUS factor
    (22) expression -> . factor MINUS factor
    (26) expression -> . LBRACKET elements RBRACKET
    (19) term -> . factor DIVIDE factor
    (20) term -> . factor TIMES factor
    (23) factor -> . INTEGER
    (24) factor -> . FLOAT
    (25) factor -> . LPAREN expression RPAREN

    RPAREN          reduce using rule 13 (empty -> .)
    LBRACKET        shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    LPAREN          shift and go to state 8

    optional_elements              shift and go to state 40
    elements                       shift and go to state 41
    empty                          shift and go to state 42
    expression                     shift and go to state 34
    term                           shift and go to state 13
    factor                         shift and go to state 14

state 24

    (25) factor -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 43


state 25

    (14) statement -> WHILE expression . statement END
    (7) statement -> . expression
    (8) statement -> . IDENTIFIER ASSIGN expression
    (9) statement -> . INSTANCE_VAR ASSIGN expression
    (10) statement -> . SETNEW LPAREN optional_elements RPAREN
    (14) statement -> . WHILE expression statement END
    (15) statement -> . IDENTIFIER ASSIGN GETS
    (16) statement -> . DEF IDENTIFIER LPAREN params RPAREN statement END
    (17) statement -> . IDENTIFIER LPAREN params RPAREN
    (29) statement -> . FOR IDENTIFIER IN range statement
    (32) statement -> . PUTS statement
    (18) expression -> . term
    (21) expression -> . factor PLUS factor
    (22) expression -> . factor MINUS factor
    (26) expression -> . LBRACKET elements RBRACKET
    (19) term -> . factor DIVIDE factor
    (20) term -> . factor TIMES factor
    (23) factor -> . INTEGER
    (24) factor -> . FLOAT
    (25) factor -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 5
    INSTANCE_VAR    shift and go to state 6
    SETNEW          shift and go to state 7
    WHILE           shift and go to state 9
    DEF             shift and go to state 10
    FOR             shift and go to state 11
    PUTS            shift and go to state 12
    LBRACKET        shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    LPAREN          shift and go to state 8

    expression                     shift and go to state 4
    statement                      shift and go to state 44
    term                           shift and go to state 13
    factor                         shift and go to state 14

state 26

    (16) statement -> DEF IDENTIFIER . LPAREN params RPAREN statement END

    LPAREN          shift and go to state 45


state 27

    (29) statement -> FOR IDENTIFIER . IN range statement

    IN              shift and go to state 46


state 28

    (32) statement -> PUTS statement .

    END             reduce using rule 32 (statement -> PUTS statement .)
    IDENTIFIER      reduce using rule 32 (statement -> PUTS statement .)
    INSTANCE_VAR    reduce using rule 32 (statement -> PUTS statement .)
    SETNEW          reduce using rule 32 (statement -> PUTS statement .)
    WHILE           reduce using rule 32 (statement -> PUTS statement .)
    DEF             reduce using rule 32 (statement -> PUTS statement .)
    FOR             reduce using rule 32 (statement -> PUTS statement .)
    PUTS            reduce using rule 32 (statement -> PUTS statement .)
    LBRACKET        reduce using rule 32 (statement -> PUTS statement .)
    INTEGER         reduce using rule 32 (statement -> PUTS statement .)
    FLOAT           reduce using rule 32 (statement -> PUTS statement .)
    LPAREN          reduce using rule 32 (statement -> PUTS statement .)
    $end            reduce using rule 32 (statement -> PUTS statement .)


state 29

    (21) expression -> factor PLUS . factor
    (23) factor -> . INTEGER
    (24) factor -> . FLOAT
    (25) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    LPAREN          shift and go to state 8

    factor                         shift and go to state 47

state 30

    (22) expression -> factor MINUS . factor
    (23) factor -> . INTEGER
    (24) factor -> . FLOAT
    (25) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    LPAREN          shift and go to state 8

    factor                         shift and go to state 48

state 31

    (19) term -> factor DIVIDE . factor
    (23) factor -> . INTEGER
    (24) factor -> . FLOAT
    (25) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    LPAREN          shift and go to state 8

    factor                         shift and go to state 49

state 32

    (20) term -> factor TIMES . factor
    (23) factor -> . INTEGER
    (24) factor -> . FLOAT
    (25) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    LPAREN          shift and go to state 8

    factor                         shift and go to state 50

state 33

    (26) expression -> LBRACKET elements . RBRACKET
    (28) elements -> elements . COMMA expression

    RBRACKET        shift and go to state 51
    COMMA           shift and go to state 52


state 34

    (27) elements -> expression .

    RBRACKET        reduce using rule 27 (elements -> expression .)
    COMMA           reduce using rule 27 (elements -> expression .)
    RPAREN          reduce using rule 27 (elements -> expression .)


state 35

    (8) statement -> IDENTIFIER ASSIGN expression .

    END             reduce using rule 8 (statement -> IDENTIFIER ASSIGN expression .)
    IDENTIFIER      reduce using rule 8 (statement -> IDENTIFIER ASSIGN expression .)
    INSTANCE_VAR    reduce using rule 8 (statement -> IDENTIFIER ASSIGN expression .)
    SETNEW          reduce using rule 8 (statement -> IDENTIFIER ASSIGN expression .)
    WHILE           reduce using rule 8 (statement -> IDENTIFIER ASSIGN expression .)
    DEF             reduce using rule 8 (statement -> IDENTIFIER ASSIGN expression .)
    FOR             reduce using rule 8 (statement -> IDENTIFIER ASSIGN expression .)
    PUTS            reduce using rule 8 (statement -> IDENTIFIER ASSIGN expression .)
    LBRACKET        reduce using rule 8 (statement -> IDENTIFIER ASSIGN expression .)
    INTEGER         reduce using rule 8 (statement -> IDENTIFIER ASSIGN expression .)
    FLOAT           reduce using rule 8 (statement -> IDENTIFIER ASSIGN expression .)
    LPAREN          reduce using rule 8 (statement -> IDENTIFIER ASSIGN expression .)
    $end            reduce using rule 8 (statement -> IDENTIFIER ASSIGN expression .)


state 36

    (15) statement -> IDENTIFIER ASSIGN GETS .

    END             reduce using rule 15 (statement -> IDENTIFIER ASSIGN GETS .)
    IDENTIFIER      reduce using rule 15 (statement -> IDENTIFIER ASSIGN GETS .)
    INSTANCE_VAR    reduce using rule 15 (statement -> IDENTIFIER ASSIGN GETS .)
    SETNEW          reduce using rule 15 (statement -> IDENTIFIER ASSIGN GETS .)
    WHILE           reduce using rule 15 (statement -> IDENTIFIER ASSIGN GETS .)
    DEF             reduce using rule 15 (statement -> IDENTIFIER ASSIGN GETS .)
    FOR             reduce using rule 15 (statement -> IDENTIFIER ASSIGN GETS .)
    PUTS            reduce using rule 15 (statement -> IDENTIFIER ASSIGN GETS .)
    LBRACKET        reduce using rule 15 (statement -> IDENTIFIER ASSIGN GETS .)
    INTEGER         reduce using rule 15 (statement -> IDENTIFIER ASSIGN GETS .)
    FLOAT           reduce using rule 15 (statement -> IDENTIFIER ASSIGN GETS .)
    LPAREN          reduce using rule 15 (statement -> IDENTIFIER ASSIGN GETS .)
    $end            reduce using rule 15 (statement -> IDENTIFIER ASSIGN GETS .)


state 37

    (3) params -> IDENTIFIER .

    RPAREN          reduce using rule 3 (params -> IDENTIFIER .)
    COMMA           reduce using rule 3 (params -> IDENTIFIER .)


state 38

    (17) statement -> IDENTIFIER LPAREN params . RPAREN
    (4) params -> params . COMMA IDENTIFIER

    RPAREN          shift and go to state 53
    COMMA           shift and go to state 54


state 39

    (9) statement -> INSTANCE_VAR ASSIGN expression .

    END             reduce using rule 9 (statement -> INSTANCE_VAR ASSIGN expression .)
    IDENTIFIER      reduce using rule 9 (statement -> INSTANCE_VAR ASSIGN expression .)
    INSTANCE_VAR    reduce using rule 9 (statement -> INSTANCE_VAR ASSIGN expression .)
    SETNEW          reduce using rule 9 (statement -> INSTANCE_VAR ASSIGN expression .)
    WHILE           reduce using rule 9 (statement -> INSTANCE_VAR ASSIGN expression .)
    DEF             reduce using rule 9 (statement -> INSTANCE_VAR ASSIGN expression .)
    FOR             reduce using rule 9 (statement -> INSTANCE_VAR ASSIGN expression .)
    PUTS            reduce using rule 9 (statement -> INSTANCE_VAR ASSIGN expression .)
    LBRACKET        reduce using rule 9 (statement -> INSTANCE_VAR ASSIGN expression .)
    INTEGER         reduce using rule 9 (statement -> INSTANCE_VAR ASSIGN expression .)
    FLOAT           reduce using rule 9 (statement -> INSTANCE_VAR ASSIGN expression .)
    LPAREN          reduce using rule 9 (statement -> INSTANCE_VAR ASSIGN expression .)
    $end            reduce using rule 9 (statement -> INSTANCE_VAR ASSIGN expression .)


state 40

    (10) statement -> SETNEW LPAREN optional_elements . RPAREN

    RPAREN          shift and go to state 55


state 41

    (11) optional_elements -> elements .
    (28) elements -> elements . COMMA expression

    RPAREN          reduce using rule 11 (optional_elements -> elements .)
    COMMA           shift and go to state 52


state 42

    (12) optional_elements -> empty .

    RPAREN          reduce using rule 12 (optional_elements -> empty .)


state 43

    (25) factor -> LPAREN expression RPAREN .

    PLUS            reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    END             reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    IDENTIFIER      reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    INSTANCE_VAR    reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    SETNEW          reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    DEF             reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    FOR             reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    PUTS            reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    INTEGER         reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    FLOAT           reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    LPAREN          reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 25 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 25 (factor -> LPAREN expression RPAREN .)


state 44

    (14) statement -> WHILE expression statement . END

    END             shift and go to state 56


state 45

    (16) statement -> DEF IDENTIFIER LPAREN . params RPAREN statement END
    (3) params -> . IDENTIFIER
    (4) params -> . params COMMA IDENTIFIER

    IDENTIFIER      shift and go to state 37

    params                         shift and go to state 57

state 46

    (29) statement -> FOR IDENTIFIER IN . range statement
    (30) range -> . INTEGER DOUBLE_DOT INTEGER
    (31) range -> . FLOAT DOUBLE_DOT FLOAT

    INTEGER         shift and go to state 59
    FLOAT           shift and go to state 60

    range                          shift and go to state 58

state 47

    (21) expression -> factor PLUS factor .

    END             reduce using rule 21 (expression -> factor PLUS factor .)
    IDENTIFIER      reduce using rule 21 (expression -> factor PLUS factor .)
    INSTANCE_VAR    reduce using rule 21 (expression -> factor PLUS factor .)
    SETNEW          reduce using rule 21 (expression -> factor PLUS factor .)
    WHILE           reduce using rule 21 (expression -> factor PLUS factor .)
    DEF             reduce using rule 21 (expression -> factor PLUS factor .)
    FOR             reduce using rule 21 (expression -> factor PLUS factor .)
    PUTS            reduce using rule 21 (expression -> factor PLUS factor .)
    LBRACKET        reduce using rule 21 (expression -> factor PLUS factor .)
    INTEGER         reduce using rule 21 (expression -> factor PLUS factor .)
    FLOAT           reduce using rule 21 (expression -> factor PLUS factor .)
    LPAREN          reduce using rule 21 (expression -> factor PLUS factor .)
    $end            reduce using rule 21 (expression -> factor PLUS factor .)
    RPAREN          reduce using rule 21 (expression -> factor PLUS factor .)
    RBRACKET        reduce using rule 21 (expression -> factor PLUS factor .)
    COMMA           reduce using rule 21 (expression -> factor PLUS factor .)


state 48

    (22) expression -> factor MINUS factor .

    END             reduce using rule 22 (expression -> factor MINUS factor .)
    IDENTIFIER      reduce using rule 22 (expression -> factor MINUS factor .)
    INSTANCE_VAR    reduce using rule 22 (expression -> factor MINUS factor .)
    SETNEW          reduce using rule 22 (expression -> factor MINUS factor .)
    WHILE           reduce using rule 22 (expression -> factor MINUS factor .)
    DEF             reduce using rule 22 (expression -> factor MINUS factor .)
    FOR             reduce using rule 22 (expression -> factor MINUS factor .)
    PUTS            reduce using rule 22 (expression -> factor MINUS factor .)
    LBRACKET        reduce using rule 22 (expression -> factor MINUS factor .)
    INTEGER         reduce using rule 22 (expression -> factor MINUS factor .)
    FLOAT           reduce using rule 22 (expression -> factor MINUS factor .)
    LPAREN          reduce using rule 22 (expression -> factor MINUS factor .)
    $end            reduce using rule 22 (expression -> factor MINUS factor .)
    RPAREN          reduce using rule 22 (expression -> factor MINUS factor .)
    RBRACKET        reduce using rule 22 (expression -> factor MINUS factor .)
    COMMA           reduce using rule 22 (expression -> factor MINUS factor .)


state 49

    (19) term -> factor DIVIDE factor .

    END             reduce using rule 19 (term -> factor DIVIDE factor .)
    IDENTIFIER      reduce using rule 19 (term -> factor DIVIDE factor .)
    INSTANCE_VAR    reduce using rule 19 (term -> factor DIVIDE factor .)
    SETNEW          reduce using rule 19 (term -> factor DIVIDE factor .)
    WHILE           reduce using rule 19 (term -> factor DIVIDE factor .)
    DEF             reduce using rule 19 (term -> factor DIVIDE factor .)
    FOR             reduce using rule 19 (term -> factor DIVIDE factor .)
    PUTS            reduce using rule 19 (term -> factor DIVIDE factor .)
    LBRACKET        reduce using rule 19 (term -> factor DIVIDE factor .)
    INTEGER         reduce using rule 19 (term -> factor DIVIDE factor .)
    FLOAT           reduce using rule 19 (term -> factor DIVIDE factor .)
    LPAREN          reduce using rule 19 (term -> factor DIVIDE factor .)
    $end            reduce using rule 19 (term -> factor DIVIDE factor .)
    RPAREN          reduce using rule 19 (term -> factor DIVIDE factor .)
    RBRACKET        reduce using rule 19 (term -> factor DIVIDE factor .)
    COMMA           reduce using rule 19 (term -> factor DIVIDE factor .)


state 50

    (20) term -> factor TIMES factor .

    END             reduce using rule 20 (term -> factor TIMES factor .)
    IDENTIFIER      reduce using rule 20 (term -> factor TIMES factor .)
    INSTANCE_VAR    reduce using rule 20 (term -> factor TIMES factor .)
    SETNEW          reduce using rule 20 (term -> factor TIMES factor .)
    WHILE           reduce using rule 20 (term -> factor TIMES factor .)
    DEF             reduce using rule 20 (term -> factor TIMES factor .)
    FOR             reduce using rule 20 (term -> factor TIMES factor .)
    PUTS            reduce using rule 20 (term -> factor TIMES factor .)
    LBRACKET        reduce using rule 20 (term -> factor TIMES factor .)
    INTEGER         reduce using rule 20 (term -> factor TIMES factor .)
    FLOAT           reduce using rule 20 (term -> factor TIMES factor .)
    LPAREN          reduce using rule 20 (term -> factor TIMES factor .)
    $end            reduce using rule 20 (term -> factor TIMES factor .)
    RPAREN          reduce using rule 20 (term -> factor TIMES factor .)
    RBRACKET        reduce using rule 20 (term -> factor TIMES factor .)
    COMMA           reduce using rule 20 (term -> factor TIMES factor .)


state 51

    (26) expression -> LBRACKET elements RBRACKET .

    END             reduce using rule 26 (expression -> LBRACKET elements RBRACKET .)
    IDENTIFIER      reduce using rule 26 (expression -> LBRACKET elements RBRACKET .)
    INSTANCE_VAR    reduce using rule 26 (expression -> LBRACKET elements RBRACKET .)
    SETNEW          reduce using rule 26 (expression -> LBRACKET elements RBRACKET .)
    WHILE           reduce using rule 26 (expression -> LBRACKET elements RBRACKET .)
    DEF             reduce using rule 26 (expression -> LBRACKET elements RBRACKET .)
    FOR             reduce using rule 26 (expression -> LBRACKET elements RBRACKET .)
    PUTS            reduce using rule 26 (expression -> LBRACKET elements RBRACKET .)
    LBRACKET        reduce using rule 26 (expression -> LBRACKET elements RBRACKET .)
    INTEGER         reduce using rule 26 (expression -> LBRACKET elements RBRACKET .)
    FLOAT           reduce using rule 26 (expression -> LBRACKET elements RBRACKET .)
    LPAREN          reduce using rule 26 (expression -> LBRACKET elements RBRACKET .)
    $end            reduce using rule 26 (expression -> LBRACKET elements RBRACKET .)
    RPAREN          reduce using rule 26 (expression -> LBRACKET elements RBRACKET .)
    RBRACKET        reduce using rule 26 (expression -> LBRACKET elements RBRACKET .)
    COMMA           reduce using rule 26 (expression -> LBRACKET elements RBRACKET .)


state 52

    (28) elements -> elements COMMA . expression
    (18) expression -> . term
    (21) expression -> . factor PLUS factor
    (22) expression -> . factor MINUS factor
    (26) expression -> . LBRACKET elements RBRACKET
    (19) term -> . factor DIVIDE factor
    (20) term -> . factor TIMES factor
    (23) factor -> . INTEGER
    (24) factor -> . FLOAT
    (25) factor -> . LPAREN expression RPAREN

    LBRACKET        shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    LPAREN          shift and go to state 8

    expression                     shift and go to state 61
    term                           shift and go to state 13
    factor                         shift and go to state 14

state 53

    (17) statement -> IDENTIFIER LPAREN params RPAREN .

    END             reduce using rule 17 (statement -> IDENTIFIER LPAREN params RPAREN .)
    IDENTIFIER      reduce using rule 17 (statement -> IDENTIFIER LPAREN params RPAREN .)
    INSTANCE_VAR    reduce using rule 17 (statement -> IDENTIFIER LPAREN params RPAREN .)
    SETNEW          reduce using rule 17 (statement -> IDENTIFIER LPAREN params RPAREN .)
    WHILE           reduce using rule 17 (statement -> IDENTIFIER LPAREN params RPAREN .)
    DEF             reduce using rule 17 (statement -> IDENTIFIER LPAREN params RPAREN .)
    FOR             reduce using rule 17 (statement -> IDENTIFIER LPAREN params RPAREN .)
    PUTS            reduce using rule 17 (statement -> IDENTIFIER LPAREN params RPAREN .)
    LBRACKET        reduce using rule 17 (statement -> IDENTIFIER LPAREN params RPAREN .)
    INTEGER         reduce using rule 17 (statement -> IDENTIFIER LPAREN params RPAREN .)
    FLOAT           reduce using rule 17 (statement -> IDENTIFIER LPAREN params RPAREN .)
    LPAREN          reduce using rule 17 (statement -> IDENTIFIER LPAREN params RPAREN .)
    $end            reduce using rule 17 (statement -> IDENTIFIER LPAREN params RPAREN .)


state 54

    (4) params -> params COMMA . IDENTIFIER

    IDENTIFIER      shift and go to state 62


state 55

    (10) statement -> SETNEW LPAREN optional_elements RPAREN .

    END             reduce using rule 10 (statement -> SETNEW LPAREN optional_elements RPAREN .)
    IDENTIFIER      reduce using rule 10 (statement -> SETNEW LPAREN optional_elements RPAREN .)
    INSTANCE_VAR    reduce using rule 10 (statement -> SETNEW LPAREN optional_elements RPAREN .)
    SETNEW          reduce using rule 10 (statement -> SETNEW LPAREN optional_elements RPAREN .)
    WHILE           reduce using rule 10 (statement -> SETNEW LPAREN optional_elements RPAREN .)
    DEF             reduce using rule 10 (statement -> SETNEW LPAREN optional_elements RPAREN .)
    FOR             reduce using rule 10 (statement -> SETNEW LPAREN optional_elements RPAREN .)
    PUTS            reduce using rule 10 (statement -> SETNEW LPAREN optional_elements RPAREN .)
    LBRACKET        reduce using rule 10 (statement -> SETNEW LPAREN optional_elements RPAREN .)
    INTEGER         reduce using rule 10 (statement -> SETNEW LPAREN optional_elements RPAREN .)
    FLOAT           reduce using rule 10 (statement -> SETNEW LPAREN optional_elements RPAREN .)
    LPAREN          reduce using rule 10 (statement -> SETNEW LPAREN optional_elements RPAREN .)
    $end            reduce using rule 10 (statement -> SETNEW LPAREN optional_elements RPAREN .)


state 56

    (14) statement -> WHILE expression statement END .

    END             reduce using rule 14 (statement -> WHILE expression statement END .)
    IDENTIFIER      reduce using rule 14 (statement -> WHILE expression statement END .)
    INSTANCE_VAR    reduce using rule 14 (statement -> WHILE expression statement END .)
    SETNEW          reduce using rule 14 (statement -> WHILE expression statement END .)
    WHILE           reduce using rule 14 (statement -> WHILE expression statement END .)
    DEF             reduce using rule 14 (statement -> WHILE expression statement END .)
    FOR             reduce using rule 14 (statement -> WHILE expression statement END .)
    PUTS            reduce using rule 14 (statement -> WHILE expression statement END .)
    LBRACKET        reduce using rule 14 (statement -> WHILE expression statement END .)
    INTEGER         reduce using rule 14 (statement -> WHILE expression statement END .)
    FLOAT           reduce using rule 14 (statement -> WHILE expression statement END .)
    LPAREN          reduce using rule 14 (statement -> WHILE expression statement END .)
    $end            reduce using rule 14 (statement -> WHILE expression statement END .)


state 57

    (16) statement -> DEF IDENTIFIER LPAREN params . RPAREN statement END
    (4) params -> params . COMMA IDENTIFIER

    RPAREN          shift and go to state 63
    COMMA           shift and go to state 54


state 58

    (29) statement -> FOR IDENTIFIER IN range . statement
    (7) statement -> . expression
    (8) statement -> . IDENTIFIER ASSIGN expression
    (9) statement -> . INSTANCE_VAR ASSIGN expression
    (10) statement -> . SETNEW LPAREN optional_elements RPAREN
    (14) statement -> . WHILE expression statement END
    (15) statement -> . IDENTIFIER ASSIGN GETS
    (16) statement -> . DEF IDENTIFIER LPAREN params RPAREN statement END
    (17) statement -> . IDENTIFIER LPAREN params RPAREN
    (29) statement -> . FOR IDENTIFIER IN range statement
    (32) statement -> . PUTS statement
    (18) expression -> . term
    (21) expression -> . factor PLUS factor
    (22) expression -> . factor MINUS factor
    (26) expression -> . LBRACKET elements RBRACKET
    (19) term -> . factor DIVIDE factor
    (20) term -> . factor TIMES factor
    (23) factor -> . INTEGER
    (24) factor -> . FLOAT
    (25) factor -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 5
    INSTANCE_VAR    shift and go to state 6
    SETNEW          shift and go to state 7
    WHILE           shift and go to state 9
    DEF             shift and go to state 10
    FOR             shift and go to state 11
    PUTS            shift and go to state 12
    LBRACKET        shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    LPAREN          shift and go to state 8

    statement                      shift and go to state 64
    expression                     shift and go to state 4
    term                           shift and go to state 13
    factor                         shift and go to state 14

state 59

    (30) range -> INTEGER . DOUBLE_DOT INTEGER

    DOUBLE_DOT      shift and go to state 65


state 60

    (31) range -> FLOAT . DOUBLE_DOT FLOAT

    DOUBLE_DOT      shift and go to state 66


state 61

    (28) elements -> elements COMMA expression .

    RBRACKET        reduce using rule 28 (elements -> elements COMMA expression .)
    COMMA           reduce using rule 28 (elements -> elements COMMA expression .)
    RPAREN          reduce using rule 28 (elements -> elements COMMA expression .)


state 62

    (4) params -> params COMMA IDENTIFIER .

    RPAREN          reduce using rule 4 (params -> params COMMA IDENTIFIER .)
    COMMA           reduce using rule 4 (params -> params COMMA IDENTIFIER .)


state 63

    (16) statement -> DEF IDENTIFIER LPAREN params RPAREN . statement END
    (7) statement -> . expression
    (8) statement -> . IDENTIFIER ASSIGN expression
    (9) statement -> . INSTANCE_VAR ASSIGN expression
    (10) statement -> . SETNEW LPAREN optional_elements RPAREN
    (14) statement -> . WHILE expression statement END
    (15) statement -> . IDENTIFIER ASSIGN GETS
    (16) statement -> . DEF IDENTIFIER LPAREN params RPAREN statement END
    (17) statement -> . IDENTIFIER LPAREN params RPAREN
    (29) statement -> . FOR IDENTIFIER IN range statement
    (32) statement -> . PUTS statement
    (18) expression -> . term
    (21) expression -> . factor PLUS factor
    (22) expression -> . factor MINUS factor
    (26) expression -> . LBRACKET elements RBRACKET
    (19) term -> . factor DIVIDE factor
    (20) term -> . factor TIMES factor
    (23) factor -> . INTEGER
    (24) factor -> . FLOAT
    (25) factor -> . LPAREN expression RPAREN

    IDENTIFIER      shift and go to state 5
    INSTANCE_VAR    shift and go to state 6
    SETNEW          shift and go to state 7
    WHILE           shift and go to state 9
    DEF             shift and go to state 10
    FOR             shift and go to state 11
    PUTS            shift and go to state 12
    LBRACKET        shift and go to state 15
    INTEGER         shift and go to state 16
    FLOAT           shift and go to state 17
    LPAREN          shift and go to state 8

    statement                      shift and go to state 67
    expression                     shift and go to state 4
    term                           shift and go to state 13
    factor                         shift and go to state 14

state 64

    (29) statement -> FOR IDENTIFIER IN range statement .

    END             reduce using rule 29 (statement -> FOR IDENTIFIER IN range statement .)
    IDENTIFIER      reduce using rule 29 (statement -> FOR IDENTIFIER IN range statement .)
    INSTANCE_VAR    reduce using rule 29 (statement -> FOR IDENTIFIER IN range statement .)
    SETNEW          reduce using rule 29 (statement -> FOR IDENTIFIER IN range statement .)
    WHILE           reduce using rule 29 (statement -> FOR IDENTIFIER IN range statement .)
    DEF             reduce using rule 29 (statement -> FOR IDENTIFIER IN range statement .)
    FOR             reduce using rule 29 (statement -> FOR IDENTIFIER IN range statement .)
    PUTS            reduce using rule 29 (statement -> FOR IDENTIFIER IN range statement .)
    LBRACKET        reduce using rule 29 (statement -> FOR IDENTIFIER IN range statement .)
    INTEGER         reduce using rule 29 (statement -> FOR IDENTIFIER IN range statement .)
    FLOAT           reduce using rule 29 (statement -> FOR IDENTIFIER IN range statement .)
    LPAREN          reduce using rule 29 (statement -> FOR IDENTIFIER IN range statement .)
    $end            reduce using rule 29 (statement -> FOR IDENTIFIER IN range statement .)


state 65

    (30) range -> INTEGER DOUBLE_DOT . INTEGER

    INTEGER         shift and go to state 68


state 66

    (31) range -> FLOAT DOUBLE_DOT . FLOAT

    FLOAT           shift and go to state 69


state 67

    (16) statement -> DEF IDENTIFIER LPAREN params RPAREN statement . END

    END             shift and go to state 70


state 68

    (30) range -> INTEGER DOUBLE_DOT INTEGER .

    IDENTIFIER      reduce using rule 30 (range -> INTEGER DOUBLE_DOT INTEGER .)
    INSTANCE_VAR    reduce using rule 30 (range -> INTEGER DOUBLE_DOT INTEGER .)
    SETNEW          reduce using rule 30 (range -> INTEGER DOUBLE_DOT INTEGER .)
    WHILE           reduce using rule 30 (range -> INTEGER DOUBLE_DOT INTEGER .)
    DEF             reduce using rule 30 (range -> INTEGER DOUBLE_DOT INTEGER .)
    FOR             reduce using rule 30 (range -> INTEGER DOUBLE_DOT INTEGER .)
    PUTS            reduce using rule 30 (range -> INTEGER DOUBLE_DOT INTEGER .)
    LBRACKET        reduce using rule 30 (range -> INTEGER DOUBLE_DOT INTEGER .)
    INTEGER         reduce using rule 30 (range -> INTEGER DOUBLE_DOT INTEGER .)
    FLOAT           reduce using rule 30 (range -> INTEGER DOUBLE_DOT INTEGER .)
    LPAREN          reduce using rule 30 (range -> INTEGER DOUBLE_DOT INTEGER .)


state 69

    (31) range -> FLOAT DOUBLE_DOT FLOAT .

    IDENTIFIER      reduce using rule 31 (range -> FLOAT DOUBLE_DOT FLOAT .)
    INSTANCE_VAR    reduce using rule 31 (range -> FLOAT DOUBLE_DOT FLOAT .)
    SETNEW          reduce using rule 31 (range -> FLOAT DOUBLE_DOT FLOAT .)
    WHILE           reduce using rule 31 (range -> FLOAT DOUBLE_DOT FLOAT .)
    DEF             reduce using rule 31 (range -> FLOAT DOUBLE_DOT FLOAT .)
    FOR             reduce using rule 31 (range -> FLOAT DOUBLE_DOT FLOAT .)
    PUTS            reduce using rule 31 (range -> FLOAT DOUBLE_DOT FLOAT .)
    LBRACKET        reduce using rule 31 (range -> FLOAT DOUBLE_DOT FLOAT .)
    INTEGER         reduce using rule 31 (range -> FLOAT DOUBLE_DOT FLOAT .)
    FLOAT           reduce using rule 31 (range -> FLOAT DOUBLE_DOT FLOAT .)
    LPAREN          reduce using rule 31 (range -> FLOAT DOUBLE_DOT FLOAT .)


state 70

    (16) statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .

    END             reduce using rule 16 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    IDENTIFIER      reduce using rule 16 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    INSTANCE_VAR    reduce using rule 16 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    SETNEW          reduce using rule 16 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    WHILE           reduce using rule 16 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    DEF             reduce using rule 16 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    FOR             reduce using rule 16 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    PUTS            reduce using rule 16 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    LBRACKET        reduce using rule 16 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    INTEGER         reduce using rule 16 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    FLOAT           reduce using rule 16 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    LPAREN          reduce using rule 16 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)
    $end            reduce using rule 16 (statement -> DEF IDENTIFIER LPAREN params RPAREN statement END .)

